var tipuesearch = {"pages":[{"title":" Fortran Logger ","text":"Fortran Logger Fortran Logger Main features Free and Open Source Project MPI Support Fortran 2008+ standard compliant Highly customizable logger and error checker CLI Support for runtime change of logging level Installation In order to build this library you will need to have modern fortran compiler installed. The only currently possible way to install library is with FoBiS.py . Next example will build static library with MPI support and optimize flags git clone https://github.com/ShatrovOA/Fortran-Logger cd Fortran-Logger\nFoBiS.py build -mode static-gnu-mpi List of available build modes can be obtained by running FoBiS.py build -lmodes Logging Format Logger format is highly customizable, which means that user can define it’s own unique way of logging. Initialization subroutine has the following interface. subroutine initialize ( self , log_level , & error_unit , error_color_fg , error_color_bg , error_style , error_prefix , error_suffix , & warn_unit , warn_color_fg , warn_color_bg , warn_style , warn_prefix , warn_suffix , & info_unit , info_color_fg , info_color_bg , info_style , info_prefix , info_suffix , & debug_unit , debug_color_fg , debug_color_bg , debug_style , debug_prefix , debug_suffix , & routine_prefix , routine_suffix , print_timestamp , timestamp_format , timestamp_color_fg , & timestamp_color_bg , timestamp_style , timestamp_prefix , timestamp_suffix ) All arguments are optional. The meaning of the arguments (except the obvious passed self) are: integer ( I4P ), intent ( in ), optional :: log_level !< Level of logging integer ( I4P ), intent ( in ), optional :: error_unit !< Unit used to print ERROR messages character ( len =* ), intent ( in ), optional :: error_color_fg !< ERROR foreground color character ( len =* ), intent ( in ), optional :: error_color_bg !< ERROR background color character ( len =* ), intent ( in ), optional :: error_style !< ERROR style character ( len =* ), intent ( in ), optional :: error_prefix !< ERROR prefix character ( len =* ), intent ( in ), optional :: error_suffix !< ERROR suffix integer ( I4P ), intent ( in ), optional :: warn_unit !< Unit used to print WARN messages character ( len =* ), intent ( in ), optional :: warn_color_fg !< WARN foreground color character ( len =* ), intent ( in ), optional :: warn_color_bg !< WARN background color character ( len =* ), intent ( in ), optional :: warn_style !< WARN style character ( len =* ), intent ( in ), optional :: warn_prefix !< WARN prefix character ( len =* ), intent ( in ), optional :: warn_suffix !< WARN suffix integer ( I4P ), intent ( in ), optional :: info_unit !< Unit used to print INFO messages character ( len =* ), intent ( in ), optional :: info_color_fg !< INFO foreground color character ( len =* ), intent ( in ), optional :: info_color_bg !< INFO background color character ( len =* ), intent ( in ), optional :: info_style !< INFO style character ( len =* ), intent ( in ), optional :: info_prefix !< INFO prefix character ( len =* ), intent ( in ), optional :: info_suffix !< INFO suffix integer ( I4P ), intent ( in ), optional :: debug_unit !< Unit used to print DEBUG messages character ( len =* ), intent ( in ), optional :: debug_color_fg !< DEBUG foreground color character ( len =* ), intent ( in ), optional :: debug_color_bg !< DEBUG background color character ( len =* ), intent ( in ), optional :: debug_style !< DEBUG style character ( len =* ), intent ( in ), optional :: debug_prefix !< DEBUG prefix character ( len =* ), intent ( in ), optional :: debug_suffix !< DEBUG suffix character ( len =* ), intent ( in ), optional :: routine_prefix !< Routine prefix. routine is optional agrument in most of logger methods character ( len =* ), intent ( in ), optional :: routine_suffix !< Routine suffix. routine is optional agrument in most of logger methods logical , intent ( in ), optional :: print_timestamp !< Display current timestamp with all messages. Default is .true. character ( len =* ), intent ( in ), optional :: timestamp_format !< Timestamp format, C style character ( len =* ), intent ( in ), optional :: timestamp_color_fg !< Timestamp foreground color character ( len =* ), intent ( in ), optional :: timestamp_color_bg !< Timestamp background color character ( len =* ), intent ( in ), optional :: timestamp_style !< Timestamp style character ( len =* ), intent ( in ), optional :: timestamp_prefix !< Timestamp prefix character ( len =* ), intent ( in ), optional :: timestamp_suffix !< Timestamp suffix If user builds library with mpi support (e.g. modes: static-gnu-mpi, shared-intel-mpi-debug) then one more argument appears, which is required: type ( MPI_Comm ), intent ( in ) :: comm !< MPI Communicator This library supports 5 levels of logging (log_level argument), defined in public parameters: LOGGER_NULL_LEVEL = 0 LOGGER_ERROR_LEVEL = 1 LOGGER_WARN_LEVEL = 2 LOGGER_INFO_LEVEL = 3 LOGGER_DEBUG_LEVEL = 4 Each level will produce more output then previous. LOGGER_NULL_LEVEL will produce no output even if fatal error occured, program will continue execution. If you don’t pass anything then LOGGER_DEBUG_LEVEL will be used. CLI support With the help of FLAP Fortran Logger supports change of log level at runtime. When you run your application use --logger_level or it’s shorter version -log_lev switch and pass desired level of logging. Value passed through CLI switch will override one you passed within initialize subroutine. Developer Info Oleg Shatrov","tags":"home","loc":"index.html"},{"title":"logger_element_object.F90 – Fortran Logger","text":"Fortran-Logger project, definition of element_object class that handles different levels outputs. Files dependent on this one sourcefile~~logger_element_object.f90~~AfferentGraph sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~fortran_logger.f90 sourcefile~test_ignore_error_codes_m.f90 test_ignore_error_codes_m.F90 sourcefile~run_tests.f90->sourcefile~test_ignore_error_codes_m.f90 sourcefile~test_check_alloc_m.f90 test_check_alloc_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_alloc_m.f90 sourcefile~test_unit_change_m.f90 test_unit_change_m.F90 sourcefile~run_tests.f90->sourcefile~test_unit_change_m.f90 sourcefile~test_check_json_m.f90 test_check_json_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_json_m.f90 sourcefile~test_ignore_error_codes_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_alloc_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_unit_change_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_json_m.f90->sourcefile~fortran_logger.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules logger_element_object Source Code logger_element_object.F90 Source Code !< Fortran-Logger project, definition of [[element_object]] class that handles different levels outputs. module logger_element_object !< Fortran-Logger project, definition of [[element_object]] class that handles different levels outputs. use penf , only : I4P use face , only : colorize use iso_fortran_env , only : output_unit implicit none private public :: element_object type :: element_object !< Definition of Object Class private integer ( I4P ) :: out_unit !< Unit used to print output character ( len = :), allocatable :: string !< Element string character ( len = :), allocatable :: color_fg !< Foreground color character ( len = :), allocatable :: color_bg !< Background color character ( len = :), allocatable :: style !< Style character ( len = :), allocatable :: prefix !< Prefix string character ( len = :), allocatable :: suffix !< Suffix string contains private ! public methods procedure , pass ( self ), public :: finalize !< Finalize element procedure , pass ( self ), public :: initialize !< Initialize element procedure , pass ( self ), public :: output !< Return formatted output of element procedure , pass ( self ), public :: update_unit !< Replace current [[out_unit]] with new one procedure , pass ( self ), public :: get_unit !< Return current [[out_unit]] endtype element_object contains !------------------------------------------------------------------------------------- pure subroutine finalize ( self ) !------------------------------------------------------------------------------------- !< Finalization class subroutine !------------------------------------------------------------------------------------- class ( element_object ), intent ( inout ) :: self !< Element self % out_unit = output_unit if ( allocated ( self % string )) deallocate ( self % string ) if ( allocated ( self % color_fg )) deallocate ( self % color_fg ) if ( allocated ( self % color_bg )) deallocate ( self % color_bg ) if ( allocated ( self % style )) deallocate ( self % style ) if ( allocated ( self % prefix )) deallocate ( self % prefix ) if ( allocated ( self % suffix )) deallocate ( self % suffix ) end subroutine finalize !------------------------------------------------------------------------------------- pure subroutine initialize ( self , out_unit , string , color_fg , color_bg , style , prefix , suffix ) !------------------------------------------------------------------------------------- !< Initialization class subroutine !------------------------------------------------------------------------------------- class ( element_object ), intent ( inout ) :: self !< Element integer ( I4P ), intent ( in ), optional :: out_unit !< Unit used to print output character ( len =* ), intent ( in ), optional :: string !< Element string character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color character ( len =* ), intent ( in ), optional :: color_bg !< Background color character ( len =* ), intent ( in ), optional :: style !< Style character ( len =* ), intent ( in ), optional :: prefix !< Prefix string character ( len =* ), intent ( in ), optional :: suffix !< Suffix string call self % finalize () if ( present ( out_unit )) self % out_unit = out_unit self % string = '' ; if ( present ( string )) self % string = string self % color_fg = '' ; if ( present ( color_fg )) self % color_fg = color_fg self % color_bg = '' ; if ( present ( color_bg )) self % color_bg = color_bg self % style = '' ; if ( present ( style )) self % style = style self % prefix = '' ; if ( present ( prefix )) self % prefix = prefix self % suffix = ' ' ; if ( present ( suffix )) self % suffix = suffix end subroutine initialize !------------------------------------------------------------------------------------- function output ( self , update_string ) !------------------------------------------------------------------------------------- !< Generate output message !------------------------------------------------------------------------------------- class ( element_object ), intent ( inout ) :: self !< Element character ( len =* ), intent ( in ), optional :: update_string !< Element string character ( len = :), allocatable :: output !< Formatted output. if ( present ( update_string )) self % string = update_string output = self % prefix // colorize ( self % string , color_fg = self % color_fg , color_bg = self % color_bg , style = self % style ) // self % suffix end function output !------------------------------------------------------------------------------------- pure function get_unit ( self ) result ( unit ) !------------------------------------------------------------------------------------- !< Returns current output unit !------------------------------------------------------------------------------------- class ( element_object ), intent ( in ) :: self !< Element integer ( I4P ) :: unit !< Output unit unit = self % out_unit end function get_unit !------------------------------------------------------------------------------------- pure subroutine update_unit ( self , new_unit ) !------------------------------------------------------------------------------------- !< Changes current output unit !------------------------------------------------------------------------------------- class ( element_object ), intent ( inout ) :: self !< Element integer ( I4P ), intent ( in ) :: new_unit !< New output unit number self % out_unit = new_unit end subroutine update_unit end module logger_element_object","tags":"","loc":"sourcefile/logger_element_object.f90.html"},{"title":"fortran_logger.F90 – Fortran Logger","text":"Fortran-Logger project, definition of fortran_logger_t class. This file depends on sourcefile~~fortran_logger.f90~~EfferentGraph sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fortran_logger.f90~~AfferentGraph sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~fortran_logger.f90 sourcefile~test_ignore_error_codes_m.f90 test_ignore_error_codes_m.F90 sourcefile~run_tests.f90->sourcefile~test_ignore_error_codes_m.f90 sourcefile~test_check_alloc_m.f90 test_check_alloc_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_alloc_m.f90 sourcefile~test_unit_change_m.f90 test_unit_change_m.F90 sourcefile~run_tests.f90->sourcefile~test_unit_change_m.f90 sourcefile~test_check_json_m.f90 test_check_json_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_json_m.f90 sourcefile~test_ignore_error_codes_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_alloc_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_unit_change_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_json_m.f90->sourcefile~fortran_logger.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fortran_logger Source Code fortran_logger.F90 Source Code !< Fortran-Logger project, definition of [[fortran_logger_t]] class. module fortran_logger !< Fortran-Logger project, definition of [[fortran_logger_t]] class. use datetime_module , only : datetime use face , only : colorize use flap use json_module use penf use logger_element_object #ifdef _MPI use mpi_f08 #endif implicit none private public :: fortran_logger_t , & LOGGER_NULL_LEVEL , & LOGGER_ERROR_LEVEL , & LOGGER_WARN_LEVEL , & LOGGER_INFO_LEVEL , & LOGGER_DEBUG_LEVEL , & LOGGER_ERROR_ALLOCATION_FAILED , & LOGGER_ERROR_JSON_VALUE_NOT_FOUND , & LOGGER_ERROR_JSON_VALUE_TYPE_MISMATCH , & LOGGER_ERROR_DIRECTORY_NOT_FOUND , & LOGGER_ERROR_FILE_NOT_FOUND integer ( I4P ), parameter :: LOGGER_NULL_LEVEL = 0_I4P !< Null Level Code !< Logger will not produce output integer ( I4P ), parameter :: LOGGER_ERROR_LEVEL = 1_I4P !< Error Level Code !< Logger will produce output only if error occurs integer ( I4P ), parameter :: LOGGER_WARN_LEVEL = 2_I4P !< Warning Level Code !< Logger will produce Error + Warning messages integer ( I4P ), parameter :: LOGGER_INFO_LEVEL = 3_I4P !< Info Level Code !< Logger will produce Error + Warning + Info messages integer ( I4P ), parameter :: LOGGER_DEBUG_LEVEL = 4_I4P !< Debug Level Code !< Logger will produce all messages integer ( I4P ), parameter :: LOGGER_ERROR_ALLOCATION_FAILED = - 999_I4P !< Internal error, allocation failure integer ( I4P ), parameter :: LOGGER_ERROR_JSON_VALUE_NOT_FOUND = - 998_I4P !< Internal error, requested value not found in json file integer ( I4P ), parameter :: LOGGER_ERROR_JSON_VALUE_TYPE_MISMATCH = - 997_I4P !< Internal error, requested value has a different type integer ( I4P ), parameter :: LOGGER_ERROR_DIRECTORY_NOT_FOUND = - 996_I4P !< Internal error, requested directory not found in the path integer ( I4P ), parameter :: LOGGER_ERROR_FILE_NOT_FOUND = - 995_I4P !< Internal error, requested file not found in the path integer ( I4P ), parameter :: LOGGER_ERROR_CONVERTED_LOGICAL = - 994_I4P !< Internal error, converted from logical value character ( len =* ), parameter , dimension ( 0 : 7 ) :: JSON_TYPES = [ & !< JSON types from json fortran library \"Unknown\" , & !< Check it out on [GitHub](https://github.com/jacobwilliams/json-fortran) \"Null   \" , & \"Object \" , & \"Array  \" , & \"Logical\" , & \"Integer\" , & \"Real   \" , & \"String \" & ] type :: fortran_logger_t !< Definition of Logger class private integer ( I4P ) :: log_level !< Level of logging type ( element_object ) :: logger_object ( 4 ) !< Objects that handle messages from all levels type ( element_object ) :: timestamp_object !< Timestamp handle type ( element_object ) :: routine_object !< Handle of optional \"routine\" parameter in most of methods logical :: print_timestamp !< Timestamp printer flag character ( len = :), allocatable :: timestamp_format !< Timestamp format, C style integer ( I4P ), allocatable :: ignored_codes (:) !< Buffer that keeps all ignored codes #ifdef _MPI integer ( I4P ), allocatable :: gather_buf (:) !< Buffer that aggregates all error codes type ( MPI_Comm ) :: comm !< MPI Communicator #endif contains private ! Public methods procedure , pass ( self ), public :: finalize !< Finalization class subroutine procedure , pass ( self ), public :: initialize !< Initialization class subroutine procedure , pass ( self ), public :: error !< Print error message procedure , pass ( self ), public :: warn !< Print warn message procedure , pass ( self ), public :: info !< Print info message procedure , pass ( self ), public :: debug !< Print debug message procedure , pass ( self ), public :: change_unit !< Runtime output unit change procedure , pass ( self ), public :: check_json_value !< Checks presence and type of value in json file procedure , pass ( self ), public :: check_directory !< Checks directory presence procedure , pass ( self ), public :: check_file !< Checks file presence generic , public :: check_error => & !< Checks error code returned by external subroutine. check_error_LOGICAL , & check_error_I1P , & check_error_I2P , & check_error_I4P , & check_error_I8P generic , public :: check_alloc => & !< Checks allocation of buffers of different types and ranks check_alloc_rank1_CR4P , & check_alloc_rank1_CR8P , & #ifdef _R16P check_alloc_rank1_CR16P , & #endif check_alloc_rank2_CR4P , & check_alloc_rank2_CR8P , & #ifdef _R16P check_alloc_rank2_CR16P , & #endif check_alloc_rank3_CR4P , & check_alloc_rank3_CR8P , & #ifdef _R16P check_alloc_rank3_CR16P , & #endif check_alloc_rank4_CR4P , & check_alloc_rank4_CR8P , & #ifdef _R16P check_alloc_rank4_CR16P , & #endif check_alloc_rank1_R4P , & check_alloc_rank1_R8P , & #ifdef _R16P check_alloc_rank1_R16P , & #endif check_alloc_rank2_R4P , & check_alloc_rank2_R8P , & #ifdef _R16P check_alloc_rank2_R16P , & #endif check_alloc_rank3_R4P , & check_alloc_rank3_R8P , & #ifdef _R16P check_alloc_rank3_R16P , & #endif check_alloc_rank4_R4P , & check_alloc_rank4_R8P , & #ifdef _R16P check_alloc_rank4_R16P , & #endif check_alloc_rank1_I1P , & check_alloc_rank1_I2P , & check_alloc_rank1_I4P , & check_alloc_rank1_I8P , & check_alloc_rank2_I1P , & check_alloc_rank2_I2P , & check_alloc_rank2_I4P , & check_alloc_rank2_I8P , & check_alloc_rank3_I1P , & check_alloc_rank3_I2P , & check_alloc_rank3_I4P , & check_alloc_rank3_I8P , & check_alloc_rank4_I1P , & check_alloc_rank4_I2P , & check_alloc_rank4_I4P , & check_alloc_rank4_I8P generic , public :: ignore_error_codes => & !< Ignore codes of various types except logical ignore_error_codes_I1P , & ignore_error_codes_I2P , & ignore_error_codes_I4P , & ignore_error_codes_I8P ! Private methods ! Check error methods procedure , pass ( self ) :: check_error_LOGICAL !< Checks logical error_code returned by external subroutine. procedure , pass ( self ) :: check_error_I1P !< Checks integer I1P error_code returned by external subroutine. procedure , pass ( self ) :: check_error_I2P !< Checks integer I2P error_code returned by external subroutine. procedure , pass ( self ) :: check_error_I4P !< Checks integer I4P error_code returned by external subroutine. procedure , pass ( self ) :: check_error_I8P !< Checks integer I8P error_code returned by external subroutine. ! Check alloc methods procedure , pass ( self ) :: check_alloc_rank1_CR4P !< Checks allocation of complex R4P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank1_CR8P !< Checks allocation of complex R8P buffer of rank = 1 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank1_CR16P !< Checks allocation of complex R16P buffer of rank = 1 #endif procedure , pass ( self ) :: check_alloc_rank2_CR4P !< Checks allocation of complex R4P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank2_CR8P !< Checks allocation of complex R8P buffer of rank = 2 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank2_CR16P !< Checks allocation of complex R16P buffer of rank = 2 #endif procedure , pass ( self ) :: check_alloc_rank3_CR4P !< Checks allocation of complex R4P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank3_CR8P !< Checks allocation of complex R8P buffer of rank = 3 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank3_CR16P !< Checks allocation of complex R16P buffer of rank = 3 #endif procedure , pass ( self ) :: check_alloc_rank4_CR4P !< Checks allocation of complex R4P buffer of rank = 4 procedure , pass ( self ) :: check_alloc_rank4_CR8P !< Checks allocation of complex R8P buffer of rank = 4 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank4_CR16P !< Checks allocation of complex R16P buffer of rank = 4 #endif procedure , pass ( self ) :: check_alloc_rank1_R4P !< Checks allocation of real R4P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank1_R8P !< Checks allocation of real R8P buffer of rank = 1 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank1_R16P !< Checks allocation of real R16P buffer of rank = 1 #endif procedure , pass ( self ) :: check_alloc_rank2_R4P !< Checks allocation of real R4P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank2_R8P !< Checks allocation of real R8P buffer of rank = 2 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank2_R16P !< Checks allocation of real R16P buffer of rank = 2 #endif procedure , pass ( self ) :: check_alloc_rank3_R4P !< Checks allocation of real R4P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank3_R8P !< Checks allocation of real R8P buffer of rank = 3 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank3_R16P !< Checks allocation of real R16P buffer of rank = 3 #endif procedure , pass ( self ) :: check_alloc_rank4_R4P !< Checks allocation of real R4P buffer of rank = 4 procedure , pass ( self ) :: check_alloc_rank4_R8P !< Checks allocation of real R8P buffer of rank = 4 #ifdef _R16P procedure , pass ( self ) :: check_alloc_rank4_R16P !< Checks allocation of real R16P buffer of rank = 4 #endif procedure , pass ( self ) :: check_alloc_rank1_I1P !< Checks allocation of integer I1P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank1_I2P !< Checks allocation of integer I2P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank1_I4P !< Checks allocation of integer I4P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank1_I8P !< Checks allocation of integer I8P buffer of rank = 1 procedure , pass ( self ) :: check_alloc_rank2_I1P !< Checks allocation of integer I1P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank2_I2P !< Checks allocation of integer I2P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank2_I4P !< Checks allocation of integer I4P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank2_I8P !< Checks allocation of integer I8P buffer of rank = 2 procedure , pass ( self ) :: check_alloc_rank3_I1P !< Checks allocation of integer I1P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank3_I2P !< Checks allocation of integer I2P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank3_I4P !< Checks allocation of integer I4P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank3_I8P !< Checks allocation of integer I8P buffer of rank = 3 procedure , pass ( self ) :: check_alloc_rank4_I1P !< Checks allocation of integer I1P buffer of rank = 4 procedure , pass ( self ) :: check_alloc_rank4_I2P !< Checks allocation of integer I2P buffer of rank = 4 procedure , pass ( self ) :: check_alloc_rank4_I4P !< Checks allocation of integer I4P buffer of rank = 4 procedure , pass ( self ) :: check_alloc_rank4_I8P !< Checks allocation of integer I8P buffer of rank = 4 ! Ignoring error codes methods procedure , pass ( self ) :: ignore_error_codes_I1P !< Ignore codes type I1P procedure , pass ( self ) :: ignore_error_codes_I2P !< Ignore codes type I2P procedure , pass ( self ) :: ignore_error_codes_I4P !< Ignore codes type I4P procedure , pass ( self ) :: ignore_error_codes_I8P !< Ignore codes type I8P ! Other private methods procedure , pass ( self ) :: gather_error_codes !< Gather error codes from all processes procedure , pass ( self ) :: print !< Print messages to specified unit endtype fortran_logger_t contains !------------------------------------------------------------------------------------- subroutine finalize ( self ) !------------------------------------------------------------------------------------- !< Finalization class subroutine !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ) :: i !< Counter self % log_level = LOGGER_DEBUG_LEVEL do i = LOGGER_ERROR_LEVEL , LOGGER_DEBUG_LEVEL call self % logger_object ( i )% finalize () enddo call self % timestamp_object % finalize () self % print_timestamp = . true . if ( allocated ( self % timestamp_format )) deallocate ( self % timestamp_format ) if ( allocated ( self % ignored_codes )) deallocate ( self % ignored_codes ) #ifdef _MPI self % comm = MPI_COMM_NULL if ( allocated ( self % gather_buf )) deallocate ( self % gather_buf ) #endif end subroutine finalize !------------------------------------------------------------------------------------- subroutine initialize ( self , & #ifdef _MPI comm , & #endif log_level , & error_unit , error_color_fg , error_color_bg , error_style , error_prefix , error_suffix , & warn_unit , warn_color_fg , warn_color_bg , warn_style , warn_prefix , warn_suffix , & info_unit , info_color_fg , info_color_bg , info_style , info_prefix , info_suffix , & debug_unit , debug_color_fg , debug_color_bg , debug_style , debug_prefix , debug_suffix , & routine_prefix , routine_suffix , print_timestamp , timestamp_format , timestamp_color_fg , & timestamp_color_bg , timestamp_style , timestamp_prefix , timestamp_suffix ) !------------------------------------------------------------------------------------- !< Initialization class subroutine !< If built with MPI support then MPI_Init must be called before calling this method !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger #ifdef _MPI type ( MPI_Comm ), intent ( in ) :: comm !< MPI Communicator #endif integer ( I4P ), intent ( in ), optional :: log_level !< Level of logging integer ( I4P ), intent ( in ), optional :: error_unit !< Unit used to print ERROR messages character ( len =* ), intent ( in ), optional :: error_color_fg !< ERROR foreground color character ( len =* ), intent ( in ), optional :: error_color_bg !< ERROR background color character ( len =* ), intent ( in ), optional :: error_style !< ERROR style character ( len =* ), intent ( in ), optional :: error_prefix !< ERROR prefix character ( len =* ), intent ( in ), optional :: error_suffix !< ERROR suffix integer ( I4P ), intent ( in ), optional :: warn_unit !< Unit used to print WARN messages character ( len =* ), intent ( in ), optional :: warn_color_fg !< WARN foreground color character ( len =* ), intent ( in ), optional :: warn_color_bg !< WARN background color character ( len =* ), intent ( in ), optional :: warn_style !< WARN style character ( len =* ), intent ( in ), optional :: warn_prefix !< WARN prefix character ( len =* ), intent ( in ), optional :: warn_suffix !< WARN suffix integer ( I4P ), intent ( in ), optional :: info_unit !< Unit used to print INFO messages character ( len =* ), intent ( in ), optional :: info_color_fg !< INFO foreground color character ( len =* ), intent ( in ), optional :: info_color_bg !< INFO background color character ( len =* ), intent ( in ), optional :: info_style !< INFO style character ( len =* ), intent ( in ), optional :: info_prefix !< INFO prefix character ( len =* ), intent ( in ), optional :: info_suffix !< INFO suffix integer ( I4P ), intent ( in ), optional :: debug_unit !< Unit used to print DEBUG messages character ( len =* ), intent ( in ), optional :: debug_color_fg !< DEBUG foreground color character ( len =* ), intent ( in ), optional :: debug_color_bg !< DEBUG background color character ( len =* ), intent ( in ), optional :: debug_style !< DEBUG style character ( len =* ), intent ( in ), optional :: debug_prefix !< DEBUG prefix character ( len =* ), intent ( in ), optional :: debug_suffix !< DEBUG suffix character ( len =* ), intent ( in ), optional :: routine_prefix !< Routine prefix. routine is optional agrument in most of logger methods character ( len =* ), intent ( in ), optional :: routine_suffix !< Routine suffix. routine is optional agrument in most of logger methods logical , intent ( in ), optional :: print_timestamp !< Display current timestamp with all messages. Default is .true. character ( len =* ), intent ( in ), optional :: timestamp_format !< Timestamp format, C style character ( len =* ), intent ( in ), optional :: timestamp_color_fg !< Timestamp foreground color character ( len =* ), intent ( in ), optional :: timestamp_color_bg !< Timestamp background color character ( len =* ), intent ( in ), optional :: timestamp_style !< Timestamp style character ( len =* ), intent ( in ), optional :: timestamp_prefix !< Timestamp prefix character ( len =* ), intent ( in ), optional :: timestamp_suffix !< Timestamp suffix type ( command_line_interface ) :: cli !< CLI parser integer ( I4P ) :: null_unit !< Unit used to hide CLI output messages integer ( I4P ) :: temp_level !< Temporal level value character ( len = :), allocatable :: this !< This method name #ifdef _MPI integer ( I4P ) :: np !< MPI number of processes #endif call self % finalize () if ( present ( log_level )) self % log_level = log_level call self % logger_object ( LOGGER_ERROR_LEVEL )% initialize ( out_unit = error_unit , string = 'ERROR' , & color_fg = error_color_fg , color_bg = error_color_bg , & style = error_style , & prefix = error_prefix , suffix = error_suffix ) call self % logger_object ( LOGGER_WARN_LEVEL )% initialize ( out_unit = warn_unit , string = 'WARN' , & color_fg = warn_color_fg , color_bg = warn_color_bg , & style = warn_style , & prefix = warn_prefix , suffix = warn_suffix ) call self % logger_object ( LOGGER_INFO_LEVEL )% initialize ( out_unit = info_unit , string = 'INFO' , & color_fg = info_color_fg , color_bg = info_color_bg , & style = info_style , & prefix = info_prefix , suffix = info_suffix ) call self % logger_object ( LOGGER_DEBUG_LEVEL )% initialize ( out_unit = debug_unit , string = 'DEBUG' , & color_fg = debug_color_fg , color_bg = debug_color_bg , & style = debug_style , & prefix = debug_prefix , suffix = debug_suffix ) call self % routine_object % initialize ( prefix = routine_prefix , suffix = routine_suffix ) if ( present ( print_timestamp )) self % print_timestamp = print_timestamp self % timestamp_format = '%c' ; if ( present ( timestamp_format )) self % timestamp_format = timestamp_format call self % timestamp_object % initialize ( color_fg = timestamp_color_fg , color_bg = timestamp_color_bg , & style = timestamp_style , & prefix = timestamp_prefix , suffix = timestamp_suffix ) #ifdef _MPI self % comm = comm call MPI_Comm_size ( self % comm , np ) allocate ( self % gather_buf ( 0 : np - 1 ), source = 0_I4P ) #endif open ( newunit = null_unit , & status = 'scratch' , & action = 'write' ) call cli % init ( ignore_unknown_clas = . true ., & usage_lun = null_unit , & error_lun = null_unit , & version_lun = null_unit , & disable_hv = . true .) call cli % add ( switch = '--logger_level' , & switch_ab = '-log_lev' , & required = . false ., & def = '4' , & act = 'store' ) call cli % parse () if ( cli % is_passed ( switch = '-log_lev' )) then call cli % get ( val = self % log_level , switch = '-log_lev' ) endif call cli % free () close ( null_unit ) if ( self % log_level > LOGGER_DEBUG_LEVEL . or . self % log_level < LOGGER_NULL_LEVEL ) then temp_level = self % log_level self % log_level = LOGGER_DEBUG_LEVEL this = 'fortran_logger_t.initialize' call self % error ( message = 'Wrong value of log_level provided: ' // trim ( str ( n = temp_level )), routine = this ) call self % error ( message = 'Assuming log_level = 4 (LOGGER_DEBUG_LEVEL)' , routine = this ) endif end subroutine initialize !------------------------------------------------------------------------------------- subroutine ignore_error_codes_I1P ( self , error_codes ) !------------------------------------------------------------------------------------- !< Some error codes, returned by external subroutines might be unimportant warnings. !< This subroutine takes array of codes integer type I1P, which will be be ignored by logger. !< No message will be displayed if one the codes occurs during execution, even if error is fatal !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P) :: status, ignored_code !< call logger%initialize() !< ignored_code = 33_I1P !< call logger%ignore_error_codes([ignored_code]) !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !< ! If status /= 0 AND ignored_code == status, then no message will be displayed !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I1P ), intent ( in ) :: error_codes (:) !< Array of error codes that will be ignored by logger integer ( I4P ), allocatable :: casted_error_codes (:) !< Error codes casted to I4P allocate ( casted_error_codes ( size ( error_codes , dim = 1 )), source = int ( error_codes , I4P )) call self % ignore_error_codes ( casted_error_codes ) deallocate ( casted_error_codes ) end subroutine ignore_error_codes_I1P !------------------------------------------------------------------------------------- subroutine ignore_error_codes_I2P ( self , error_codes ) !------------------------------------------------------------------------------------- !< Some error codes, returned by external subroutines might be unimportant warnings. !< This subroutine takes array of codes integer type I2P, which will be be ignored by logger. !< No message will be displayed if one the codes occurs during execution, even if error is fatal !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P) :: status, ignored_code !< call logger%initialize() !< ignored_code = 33_I2P !< call logger%ignore_error_codes([ignored_code]) !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !< ! If status /= 0 AND ignored_code == status, then no message will be displayed !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I2P ), intent ( in ) :: error_codes (:) !< Array of error codes that will be ignored by logger integer ( I4P ), allocatable :: casted_error_codes (:) !< Error codes casted to I4P allocate ( casted_error_codes ( size ( error_codes , dim = 1 )), source = int ( error_codes , I4P )) call self % ignore_error_codes ( casted_error_codes ) deallocate ( casted_error_codes ) end subroutine ignore_error_codes_I2P !------------------------------------------------------------------------------------- subroutine ignore_error_codes_I4P ( self , error_codes ) !------------------------------------------------------------------------------------- !< Some error codes, returned by external subroutines might be unimportant warnings. !< This subroutine takes array of codes integer type I4P, which will be be ignored by logger. !< No message will be displayed if one the codes occurs during execution, even if error is fatal !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P) :: status, ignored_code !< call logger%initialize() !< ignored_code = 33_I4P !< call logger%ignore_error_codes([ignored_code]) !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !< ! If status /= 0 AND ignored_code == status, then no message will be displayed !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), intent ( in ) :: error_codes (:) !< Array of error codes that will be ignored by logger integer ( I4P ) :: new_ignored_codes_count !< Size of error_codes integer ( I4P ) :: old_ignored_codes_count !< Size of logger ignored_codes integer ( I4P ) :: total_ignored_codes_count !< new_ignored_codes_count + old_ignored_codes_count integer ( I4P ), allocatable :: ignored_codes (:) !< Temporal buffer new_ignored_codes_count = size ( error_codes , dim = 1 ) if ( allocated ( self % ignored_codes )) then old_ignored_codes_count = size ( self % ignored_codes , dim = 1 ) allocate ( ignored_codes ( old_ignored_codes_count ), source = self % ignored_codes ) total_ignored_codes_count = new_ignored_codes_count + old_ignored_codes_count deallocate ( self % ignored_codes ) allocate ( self % ignored_codes ( total_ignored_codes_count )) self % ignored_codes (: old_ignored_codes_count ) = ignored_codes (:) self % ignored_codes ( old_ignored_codes_count + 1 :) = error_codes (:) deallocate ( ignored_codes ) else allocate ( self % ignored_codes ( new_ignored_codes_count )) self % ignored_codes (:) = error_codes (:) endif end subroutine ignore_error_codes_I4P !------------------------------------------------------------------------------------- subroutine ignore_error_codes_I8P ( self , error_codes ) !------------------------------------------------------------------------------------- !< Some error codes, returned by external subroutines might be unimportant warnings. !< This subroutine takes array of codes integer type I8P, which will be be ignored by logger. !< No message will be displayed if one the codes occurs during execution, even if error is fatal !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P) :: status, ignored_code !< call logger%initialize() !< ignored_code = 33_I8P !< call logger%ignore_error_codes([ignored_code]) !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !< ! If status /= 0 AND ignored_code == status, then no message will be displayed !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I8P ), intent ( in ) :: error_codes (:) !< Array of error codes that will be ignored by logger integer ( I4P ), allocatable :: casted_error_codes (:) !< Error codes casted to I4P allocate ( casted_error_codes ( size ( error_codes , dim = 1 )), source = int ( error_codes , I4P )) call self % ignore_error_codes ( casted_error_codes ) deallocate ( casted_error_codes ) end subroutine ignore_error_codes_I8P !------------------------------------------------------------------------------------- subroutine change_unit ( self , log_level , new_unit ) !------------------------------------------------------------------------------------- !< Will change output unit for the specified logging level !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), intent ( in ) :: log_level !< Logging level integer ( I4P ), intent ( in ) :: new_unit !< New output unit for specified log_level character ( len = :), allocatable :: this !< This method name if ( log_level > LOGGER_DEBUG_LEVEL . or . self % log_level < LOGGER_ERROR_LEVEL ) then this = 'fortran_logger_t.change_unit' call self % error ( \"Wrong value of log_level provided: \" // trim ( str ( n = log_level , no_sign = . true .)), routine = this ) call self % error ( \"Unit will not be changed...\" , routine = this ) else call self % logger_object ( log_level )% update_unit ( new_unit ) endif end subroutine change_unit !------------------------------------------------------------------------------------- subroutine debug ( self , message , routine , file , line ) !------------------------------------------------------------------------------------- !< Will print debug message if current logging level = [[LOGGER_DEBUG_LEVEL]] !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: message !< Message to be printed character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where debug was called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where debug was called, e.g. \\_\\_LINE\\_\\_ if ( self % log_level == LOGGER_DEBUG_LEVEL ) then call self % print ( LOGGER_DEBUG_LEVEL , message , routine = routine , file = file , line = line ) endif end subroutine debug !------------------------------------------------------------------------------------- subroutine info ( self , message , routine , file , line ) !------------------------------------------------------------------------------------- !< Will print info message if current logging level >= [[LOGGER_INFO_LEVEL]] !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: message !< Message to be printed character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where info was called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where info was called, e.g. \\_\\_LINE\\_\\_ if ( self % log_level >= LOGGER_INFO_LEVEL ) then call self % print ( LOGGER_INFO_LEVEL , message , routine = routine , file = file , line = line ) endif end subroutine info !------------------------------------------------------------------------------------- subroutine warn ( self , message , routine , file , line ) !------------------------------------------------------------------------------------- !< Will print warn message if current logging level >= [[LOGGER_WARN_LEVEL]] !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: message !< Message to be printed character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where warn was called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where warn was called, e.g. \\_\\_LINE\\_\\_ if ( self % log_level >= LOGGER_WARN_LEVEL ) then call self % print ( LOGGER_WARN_LEVEL , message , routine = routine , file = file , line = line ) endif end subroutine warn !------------------------------------------------------------------------------------- #ifdef _MPI subroutine error ( self , message , routine , file , line , error_code , errored_rank , is_fatal ) #else subroutine error ( self , message , routine , file , line , error_code , is_fatal ) #endif !------------------------------------------------------------------------------------- !< Will print error message if current logging level >= [[LOGGER_ERROR_LEVEL]]. !< If is_fatal = .true., program will stop execution. !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: message !< Message to be printed character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where error was called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where error was called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ), intent ( in ), optional :: error_code !< Internal subroutine returned error code #ifdef _MPI integer ( I4P ), intent ( in ), optional :: errored_rank !< Rank where error occured #endif logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. logical :: fatal_error !< Fatal error. Default is .false. if ( present ( error_code )) then if ( allocated ( self % ignored_codes )) then ! Ignoring specified error codes if ( any ( error_code == self % ignored_codes )) return endif endif if ( self % log_level >= LOGGER_ERROR_LEVEL ) then fatal_error = . false .; if ( present ( is_fatal )) fatal_error = is_fatal #ifdef _MPI call self % print ( LOGGER_ERROR_LEVEL , message , routine = routine , file = file , line = line , error_code = error_code , rank = errored_rank ) #else call self % print ( LOGGER_ERROR_LEVEL , message , routine = routine , file = file , line = line , error_code = error_code ) #endif if ( fatal_error ) then call self % print ( LOGGER_ERROR_LEVEL , 'This error is fatal. Program will stop executing now...' , routine = routine ) call self % finalize () #ifdef _MPI call MPI_Finalize () #endif error stop 'Fortran logger aborted execution of program due to fatal error occured' endif endif end subroutine error !------------------------------------------------------------------------------------- subroutine gather_error_codes ( self , message , error_code , routine , file , line , is_fatal , gathered_code ) !------------------------------------------------------------------------------------- !< Gather error codes from all processes !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: message !< Message to be printed class ( * ), intent ( in ) :: error_code !< Internal subroutine returned error code character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where error might have occured, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where error might have occured, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. integer ( I4P ), intent ( out ), optional :: gathered_code !< Aggregated error code similar on all processes. character ( len = 500 ) :: internal_message !< Aggregated message to be printed integer ( I4P ) :: positive_error_code !< Absolute value of error_code. integer ( I4P ) :: gathered_error_code !< Aggregated error code similar on all processes. #ifdef _MPI integer ( I4P ) :: msg_length !< Length of the message integer ( I4P ) :: errored_rank !< Rank where error occured #endif internal_message = message select type ( error_code ) type is ( integer ( I1P )) positive_error_code = int ( abs ( error_code ), I4P ) gathered_error_code = int ( error_code , I4P ) type is ( integer ( I2P )) positive_error_code = int ( abs ( error_code ), I4P ) gathered_error_code = int ( error_code , I4P ) type is ( integer ( I4P )) positive_error_code = abs ( error_code ) gathered_error_code = error_code type is ( integer ( I8P )) positive_error_code = int ( abs ( error_code ), I4P ) gathered_error_code = int ( error_code , I4P ) endselect #ifdef _MPI call MPI_Allgather ( positive_error_code , 1 , MPI_INTEGER , self % gather_buf , 1 , MPI_INTEGER , self % comm ) errored_rank = maxloc ( self % gather_buf , dim = 1 ) - 1 call MPI_Bcast ( gathered_error_code , 1 , MPI_INTEGER , errored_rank , self % comm ) msg_length = len ( internal_message ) call MPI_Bcast ( internal_message , msg_length , MPI_CHARACTER , errored_rank , self % comm ) #endif if ( gathered_error_code /= 0_I4P ) then #ifdef _MPI call self % error ( trim ( internal_message ), routine = routine , error_code = gathered_error_code , errored_rank = errored_rank , is_fatal = is_fatal , file = file , line = line ) #else call self % error ( trim ( internal_message ), routine = routine , error_code = gathered_error_code , is_fatal = is_fatal , file = file , line = line ) #endif endif if ( present ( gathered_code )) gathered_code = gathered_error_code end subroutine gather_error_codes !------------------------------------------------------------------------------------- subroutine check_json_value ( self , json , json_path , expected_type , routine , is_fatal , file , line , error ) !------------------------------------------------------------------------------------- !< Checks presence and type of value in json file !< !<```fortran !< use json_module, only: json_file, json_string !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< type(json_file)  :: json !< character(len=:), allocatable :: json_path !< integer(I4P) :: error !< !< call logger%initialize() !< call json%load_file('my_config.json') !< json_path = 'logger.test.check_json_value' !< call logger%check_json_value(json, json_path, json_string, error = error) !< if(error == 0) call json%get(json_path,success) !< call json%destroy() !< call logger%finalize() !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger class ( json_file ), intent ( inout ) :: json !< JSON handle character ( len =* ), intent ( in ) :: json_path !< Path to variable integer ( I4P ), intent ( in ) :: expected_type !< Expected variable datatype character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. character ( len =* ), intent ( in ), optional :: file !< Source file name where json is being checked, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where json is being checked, e.g. \\_\\_LINE\\_\\_ integer ( I4P ), intent ( out ), optional :: error !< Error code character ( len = :), allocatable :: message !< Error message integer ( I4P ) :: recieved_type !< Actual datatype found in JSON path integer ( I4P ) :: error_code !< Internal error code integer ( I4P ) :: gathered_code !< Aggregated internal error code logical :: is_value_found !< Is value found in JSON path flag message = '' error_code = 0_I4P call json % info ( json_path , found = is_value_found , var_type = recieved_type ) if (. not . is_value_found ) then message = 'JSON Path \"' // json_path // '\"' // \" doesn't exist;\" error_code = LOGGER_ERROR_JSON_VALUE_NOT_FOUND elseif ( expected_type /= recieved_type ) then message = 'JSON Path \"' // json_path // '\": ' // 'expected datatype is ' // colorize ( trim ( JSON_TYPES ( expected_type )), color_fg = 'cyan' ) // & ', but found ' // colorize ( trim ( JSON_TYPES ( recieved_type )), color_fg = 'red' ) // ' instead;' error_code = LOGGER_ERROR_JSON_VALUE_TYPE_MISMATCH endif call self % gather_error_codes ( message , error_code , routine = routine , file = file , line = line , is_fatal = is_fatal , gathered_code = gathered_code ) if ( present ( error )) error = gathered_code end subroutine check_json_value !------------------------------------------------------------------------------------- subroutine check_directory ( self , dir_path , is_create , routine , file , line , is_fatal , error ) !------------------------------------------------------------------------------------- !< Checks directory presence in the specified path !< If directory doesn't exist, logger can create it. !< Attention! This subroutine is collective. All MPI Processes must call it. !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len = * ), intent ( in ) :: dir_path !< Path to directory logical , intent ( in ) :: is_create !< Create directory if it doesn't exist character ( len = * ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where directory is being checked, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where directory is being checked, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. integer ( I4P ), intent ( out ), optional :: error !< Error code integer ( I4P ) :: error_code !< Internal error code integer ( I4P ) :: gathered_code !< Aggregated internal error code logical :: exist !< Is directory found flag #ifdef __INTEL_COMPILER inquire ( directory = dir_path , exist = exist ) #else inquire ( file = dir_path , exist = exist ) #endif error_code = 0_I4P ; if (. not . exist ) error_code = LOGGER_ERROR_DIRECTORY_NOT_FOUND call self % gather_error_codes ( 'Directory \"' // dir_path // '\"' // \" doesn't exist;\" , error_code , routine = routine , file = file , line = line , & is_fatal = is_fatal , gathered_code = gathered_code ) if (. not . exist . and . is_create ) then ! TODO next info message should be generated by correct MPI rank call self % info ( 'Creating directory \"' // dir_path // '\"' , routine = routine ) call execute_command_line ( 'mkdir -p ' // dir_path ) endif if ( present ( error )) error = gathered_code end subroutine check_directory !------------------------------------------------------------------------------------- subroutine check_file ( self , file_path , routine , file , line , is_fatal , error ) !------------------------------------------------------------------------------------- !< Checks file presence in the specified path !< Attention! This subroutine is collective. All MPI Processes must call it. !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len = * ), intent ( in ) :: file_path !< Path to directory character ( len = * ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where directory is being checked, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where directory is being checked, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. integer ( I4P ), intent ( out ), optional :: error !< Error code integer ( I4P ) :: error_code !< Internal error code integer ( I4P ) :: gathered_code !< Aggregated internal error code logical :: exist !< Is file found flag inquire ( file = file_path , exist = exist ) error_code = 0_I4P ; if (. not . exist ) error_code = LOGGER_ERROR_FILE_NOT_FOUND call self % gather_error_codes ( 'File \"' // file_path // '\"' // \" doesn't exist;\" , error_code , routine = routine , file = file , line = line , & is_fatal = is_fatal , gathered_code = gathered_code ) if ( present ( error )) error = gathered_code end subroutine check_file !------------------------------------------------------------------------------------- subroutine check_error_LOGICAL ( self , check_routine , error_code , routine , file , line , is_fatal ) !------------------------------------------------------------------------------------- !< Checks logical error_code returned by external subroutine. !< If error occurs and is_fatal = .true., program will stop execution. !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< logical :: status !< call logger%initialize() !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: check_routine !< Name of the external subroutine, e.g. MPI_Bcast logical , intent ( in ) :: error_code !< Error code returned by external subroutine character ( len = * ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_error is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_error is being called, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Fatal error. Default is .false. !< Default is .false. integer ( I4P ) :: converted_error_code !< Error code converted to I4P converted_error_code = LOGGER_ERROR_CONVERTED_LOGICAL ; if ( error_code ) converted_error_code = 0_I4P call self % check_error ( check_routine , converted_error_code , routine = routine , file = file , line = line , is_fatal = is_fatal ) end subroutine check_error_LOGICAL !------------------------------------------------------------------------------------- subroutine check_error_I1P ( self , check_routine , error_code , routine , file , line , is_fatal ) !------------------------------------------------------------------------------------- !< Checks integer I1P error_code returned by external subroutine. !< If error occurs and is_fatal = .true., program will stop execution. !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P) :: status !< call logger%initialize() !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: check_routine !< Name of the external subroutine, e.g. MPI_Bcast integer ( I1P ), intent ( in ) :: error_code !< Error code returned by external subroutine character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_error is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_error is being called, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Flag to stop execution is error occurs !< Default is .false. call self % gather_error_codes ( 'Subroutine \"' // check_routine // '\" returned' , error_code , routine = routine , file = file , line = line , is_fatal = is_fatal ) end subroutine check_error_I1P !------------------------------------------------------------------------------------- subroutine check_error_I2P ( self , check_routine , error_code , routine , file , line , is_fatal ) !------------------------------------------------------------------------------------- !< Checks integer I2P error_code returned by external subroutine. !< If error occurs and is_fatal = .true., program will stop execution. !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P) :: status !< call logger%initialize() !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: check_routine !< Name of the external subroutine, e.g. MPI_Bcast integer ( I2P ), intent ( in ) :: error_code !< Error code returned by external subroutine character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_error is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_error is being called, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Flag to stop execution is error occurs !< Default is .false. call self % gather_error_codes ( 'Subroutine \"' // check_routine // '\" returned' , error_code , routine = routine , file = file , line = line , is_fatal = is_fatal ) end subroutine check_error_I2P !------------------------------------------------------------------------------------- subroutine check_error_I4P ( self , check_routine , error_code , routine , file , line , is_fatal ) !------------------------------------------------------------------------------------- !< Checks integer I4P error_code returned by external subroutine. !< If error occurs and is_fatal = .true., program will stop execution. !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P) :: status !< call logger%initialize() !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: check_routine !< Name of the external subroutine, e.g. MPI_Bcast integer ( I4P ), intent ( in ) :: error_code !< Error code returned by external subroutine character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_error is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_error is being called, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Flag to stop execution is error occurs !< Default is .false. call self % gather_error_codes ( 'Subroutine \"' // check_routine // '\" returned' , error_code , routine = routine , file = file , line = line , is_fatal = is_fatal ) end subroutine check_error_I4P !------------------------------------------------------------------------------------- subroutine check_error_I8P ( self , check_routine , error_code , routine , file , line , is_fatal ) !------------------------------------------------------------------------------------- !< Checks integer I8P error_code returned by external subroutine. !< If error occurs and is_fatal = .true., program will stop execution. !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P) :: status !< call logger%initialize() !< call external_subroutine(.., status) !< call logger%check_error('external_subroutine', status) !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger character ( len =* ), intent ( in ) :: check_routine !< Name of the external subroutine, e.g. MPI_Bcast integer ( I8P ), intent ( in ) :: error_code !< Error code returned by external subroutine character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_error is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_error is being called, e.g. \\_\\_LINE\\_\\_ logical , intent ( in ), optional :: is_fatal !< Flag to stop execution is error occurs !< Default is .false. call self % gather_error_codes ( 'Subroutine \"' // check_routine // '\" returned' , error_code , routine = routine , file = file , line = line , is_fatal = is_fatal ) end subroutine check_error_I8P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_CR4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R4P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R4P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R4P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_CR4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_CR8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R8P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R8P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R8P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_CR8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_CR16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R16P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R16P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R16P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_CR16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_CR4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R4P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R4P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R4P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_CR4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_CR8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R8P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R8P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R8P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_CR8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_CR16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R16P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R16P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R16P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_CR16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_CR4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R4P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R4P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R4P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_CR4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_CR8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R8P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R8P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R8P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_CR8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_CR16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R16P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R16P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R16P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_CR16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_CR4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R4P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R4P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R4P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_CR4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_CR8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R8P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R8P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R8P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_CR8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_CR16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of complex R16P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< complex(R16P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger complex ( R16P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_CR16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_R4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R4P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R4P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R4P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_R4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_R8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R8P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R8P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R8P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_R8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_R16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R16P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R16P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R16P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_R16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_R4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R4P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R4P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R4P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_R4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_R8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R8P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R8P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R8P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_R8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_R16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R16P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R16P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R16P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_R16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_R4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R4P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R4P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R4P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_R4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_R8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R8P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R8P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R8P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_R8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_R16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R16P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R16P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R16P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_R16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_R4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R4P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R4P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R4P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_R4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_R8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R8P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R8P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R8P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_R8P #ifdef _R16P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_R16P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of real R16P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< real(R16P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger real ( R16P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_R16P #endif !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_I1P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I1P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I1P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_I1P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_I2P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I2P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I2P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_I2P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_I4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I4P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_I4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank1_I8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I8P buffer of rank = 1 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P), allocatable :: my_buffer(:) !< call logger%initialize() !< allocate(my_buffer(10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I8P ), allocatable , intent ( in ) :: buffer (:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank1_I8P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_I1P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I1P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I1P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_I1P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_I2P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I2P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I2P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_I2P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_I4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I4P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_I4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank2_I8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I8P buffer of rank = 2 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P), allocatable :: my_buffer(:,:) !< call logger%initialize() !< allocate(my_buffer(10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I8P ), allocatable , intent ( in ) :: buffer (:,:) !< Buffer to be checked character ( len =* ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank2_I8P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_I1P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I1P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I1P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_I1P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_I2P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I2P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I2P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_I2P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_I4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I4P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_I4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank3_I8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I8P buffer of rank = 3 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P), allocatable :: my_buffer(:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I8P ), allocatable , intent ( in ) :: buffer (:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank3_I8P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_I1P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I1P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I1P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I1P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_I1P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_I2P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I2P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I2P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I2P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_I2P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_I4P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I4P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I4P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_I4P !------------------------------------------------------------------------------------- subroutine check_alloc_rank4_I8P ( self , buffer , buffer_name , routine , file , line ) !------------------------------------------------------------------------------------- !< Checks allocation of integer I8P buffer of rank = 4 !< Program will stop execution if buffer was not allocated !< Attention! This subroutine is collective. All MPI Processes must call it. !< !<```fortran !< use fortran_logger !< use penf !< type(fortran_logger_t) :: logger !< integer(I8P), allocatable :: my_buffer(:,:,:,:) !< call logger%initialize() !< allocate(my_buffer(10,10,10,10)) !< call logger%check_alloc(my_buffer, 'my_buffer') !<``` !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I8P ), allocatable , intent ( in ) :: buffer (:,:,:,:) !< Buffer to be checked character ( len = * ), intent ( in ) :: buffer_name !< Name of the Buffer character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name where check_alloc is being called, e.g. \\_\\_FILE\\_\\_ integer ( I4P ), intent ( in ), optional :: line !< Line where check_alloc is being called, e.g. \\_\\_LINE\\_\\_ integer ( I4P ) :: error_code !< logger error code error_code = 0_I4P ; if (. not . allocated ( buffer )) error_code = LOGGER_ERROR_ALLOCATION_FAILED call self % gather_error_codes ( 'Allocation of \"' // buffer_name // '\" failed;' , error_code , routine = routine , file = file , line = line , is_fatal = . true .) end subroutine check_alloc_rank4_I8P !------------------------------------------------------------------------------------- #ifdef _MPI subroutine print ( self , level , message , routine , line , file , error_code , rank ) #else subroutine print ( self , level , message , routine , line , file , error_code ) #endif !------------------------------------------------------------------------------------- !< Logger printer !------------------------------------------------------------------------------------- class ( fortran_logger_t ), intent ( inout ) :: self !< Logger integer ( I4P ), intent ( in ) :: level !< Level of the message character ( len =* ), intent ( in ) :: message !< Message to be printed character ( len =* ), intent ( in ), optional :: routine !< Internal subroutine name character ( len =* ), intent ( in ), optional :: file !< Source file name integer ( I4P ), intent ( in ), optional :: line !< Source file line integer ( I4P ), intent ( in ), optional :: error_code !< Occured error code #ifdef _MPI integer ( I4P ), intent ( in ), optional :: rank !< MPI rank #endif character ( len = :), allocatable :: buffer !< Message buffer type ( datetime ) :: dtime !< datetime object buffer = '' if ( self % print_timestamp ) then dtime = dtime % now () buffer = buffer // self % timestamp_object % output ( dtime % strftime ( self % timestamp_format )) endif buffer = buffer // self % logger_object ( level )% output () if ( present ( routine )) buffer = buffer // self % routine_object % output ( routine ) buffer = buffer // '  ' // message if ( present ( error_code )) buffer = buffer // ' error code ' // trim ( str ( error_code )) #ifdef _MPI if ( present ( rank )) buffer = buffer // ' on rank ' // trim ( str ( n = rank , no_sign = . true .)) #endif if ( present ( file ). or . present ( line )) then buffer = buffer // ' (' if ( present ( file )) buffer = buffer // 'file: \"' // file // '\"' if ( present ( line )) then if ( present ( file )) buffer = buffer // ', ' buffer = buffer // 'line: ' // trim ( str ( line , no_sign = . true .)) endif buffer = buffer // ')' endif write ( self % logger_object ( level )% get_unit (), '(a)' ) buffer flush ( self % logger_object ( level )% get_unit ()) end subroutine print end module fortran_logger","tags":"","loc":"sourcefile/fortran_logger.f90.html"},{"title":"run_tests.F90 – Fortran Logger","text":"This file depends on sourcefile~~run_tests.f90~~EfferentGraph sourcefile~run_tests.f90 run_tests.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~run_tests.f90->sourcefile~fortran_logger.f90 sourcefile~test_ignore_error_codes_m.f90 test_ignore_error_codes_m.F90 sourcefile~run_tests.f90->sourcefile~test_ignore_error_codes_m.f90 sourcefile~test_check_alloc_m.f90 test_check_alloc_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_alloc_m.f90 sourcefile~test_unit_change_m.f90 test_unit_change_m.F90 sourcefile~run_tests.f90->sourcefile~test_unit_change_m.f90 sourcefile~test_check_json_m.f90 test_check_json_m.F90 sourcefile~run_tests.f90->sourcefile~test_check_json_m.f90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 sourcefile~test_ignore_error_codes_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_alloc_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_unit_change_m.f90->sourcefile~fortran_logger.f90 sourcefile~test_check_json_m.f90->sourcefile~fortran_logger.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs run_tests Source Code run_tests.F90 Source Code program run_tests !< Program designed to test Fortran Logger use iso_fortran_env , only : error_unit , output_unit use fortran_logger , only : fortran_logger_t , LOGGER_DEBUG_LEVEL use test_check_alloc_m , only : test_check_alloc use test_ignore_error_codes_m , only : test_ignore_error_codes use test_unit_change_m , only : test_unit_change use test_check_json_m , only : test_check_json use penf , only : I4P #ifdef _MPI use mpi_f08 #endif implicit none type ( fortran_logger_t ) :: logger !< Fortran logger class integer ( I4P ) :: rank !< MPI process number integer ( I4P ) :: np !< MPI number of processes integer ( I4P ) :: null_unit !< Unit connected to \"/dev/null\" integer ( I4P ) :: out_unit !< Unit used to print info and debug messages: stdout on rank = 0 and null_unit otherwise integer ( I4P ) :: err_unit !< Unit used to print error and warn messages: stderr on rank = 0 and null_unit otherwise #ifdef _MPI ! MPI_Init must be called before initializing logger call MPI_Init () call MPI_Comm_rank ( MPI_COMM_WORLD , rank ) call MPI_Comm_size ( MPI_COMM_WORLD , np ) #else rank = 0 np = 1 #endif open ( newunit = null_unit , & file = '/dev/null' , & action = 'write' ) out_unit = null_unit ; if ( rank == 0 ) out_unit = output_unit err_unit = null_unit ; if ( rank == 0 ) err_unit = error_unit ! comm is the only required parameter. It must be passed when compiled with mpi support call logger % initialize ( & #ifdef _MPI MPI_COMM_WORLD , & #endif log_level = LOGGER_DEBUG_LEVEL , & error_unit = err_unit , error_color_fg = 'red_intense' , error_prefix = '[' , error_suffix = ']' , & warn_unit = err_unit , warn_color_fg = 'yellow' , warn_prefix = '[' , warn_suffix = ']' , & info_unit = out_unit , info_color_fg = 'green' , info_prefix = '[' , info_suffix = ']' , & debug_unit = out_unit , debug_color_fg = 'cyan' , debug_prefix = '[' , debug_suffix = ']' , & routine_prefix = '[' , routine_suffix = ']' , print_timestamp = . true ., & timestamp_format = '%b %d %G %T' , timestamp_prefix = '[' , timestamp_suffix = ']' ) call logger % info ( '---------------------------------------------------------------' ) call logger % info ( '                   Fortran Logger Tests                        ' ) call logger % info ( '---------------------------------------------------------------' ) call test_check_alloc ( logger ) #ifdef _MPI call MPI_Barrier ( MPI_COMM_WORLD ) #endif call test_unit_change ( logger , rank , np , null_unit ) #ifdef _MPI call MPI_Barrier ( MPI_COMM_WORLD ) #endif call test_ignore_error_codes ( logger ) #ifdef _MPI call MPI_Barrier ( MPI_COMM_WORLD ) #endif call test_check_json ( logger , rank ) #ifdef _MPI call MPI_Barrier ( MPI_COMM_WORLD ) #endif call logger % info ( '---------------------------------------------------------------' ) call logger % info ( '                   All Tests passed!                           ' ) call logger % info ( '---------------------------------------------------------------' ) close ( null_unit ) call logger % finalize () #ifdef _MPI call MPI_Finalize () #endif end program run_tests","tags":"","loc":"sourcefile/run_tests.f90.html"},{"title":"test_check_json_m.F90 – Fortran Logger","text":"This file depends on sourcefile~~test_check_json_m.f90~~EfferentGraph sourcefile~test_check_json_m.f90 test_check_json_m.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~test_check_json_m.f90->sourcefile~fortran_logger.f90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~test_check_json_m.f90~~AfferentGraph sourcefile~test_check_json_m.f90 test_check_json_m.F90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~test_check_json_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules test_check_json_m Source Code test_check_json_m.F90 Source Code module test_check_json_m !< Module to test check_json_value, check_directory and check_file of Fortran Logger use json_module , only : json_file , JCK => json_CK , json_string , json_integer , json_logical , json_real , json_array use penf use fortran_logger , only : fortran_logger_t implicit none private public :: test_check_json contains subroutine test_check_json ( logger , rank ) !< Tester subroutine class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I4P ), intent ( in ) :: rank !< MPI processes number type ( json_file ) :: json !< JSON file character ( len = :), allocatable :: this !< This subroutine name character ( len = :), allocatable :: dirname !< Name of directory with JSON file character ( len = :), allocatable :: filename !< Name of JSON file character ( len = :), allocatable :: json_path !< Path inside JSON integer ( I4P ) :: error_code !< Error code integer ( I4P ) :: integer_value !< Integer value taken from JSON real ( R8P ) :: float_value !< Float value taken from JSON integer ( I4P ), allocatable :: integer_array (:) !< Array of Integers taken from JSON logical :: logical_value !< Logical value taken from JSON character ( kind = JCK , len = :), allocatable :: string_value !< String value taken from JSON real ( R8P ), allocatable :: float_array (:) !< Array of Floats taken from JSON this = 'test_check_json' call logger % info ( '***************************************************************' ) call logger % info ( '               Testing system and JSON methods                 ' ) call logger % info ( '***************************************************************' ) dirname = 'files' call logger % check_directory ( dirname , . false ., routine = this , is_fatal = . true .) filename = dirname // '/test_file.json' call logger % check_file ( filename , routine = this , is_fatal = . true .) call json % load_file ( filename ) json_path = 'Integer value' call logger % check_json_value ( json , json_path , json_integer , routine = this , file = __ FILE__ , line = __ LINE__ , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , integer_value ) json_path = 'Float value' call logger % check_json_value ( json , json_path , json_real , routine = this , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , float_value ) json_path = 'Array of integers' call logger % check_json_value ( json , json_path , json_array , routine = this , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , integer_array ) json_path = 'Logical value' call logger % check_json_value ( json , json_path , json_logical , routine = this , file = __ FILE__ , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , logical_value ) json_path = 'String value' call logger % check_json_value ( json , json_path , json_string , routine = this , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , string_value ) json_path = 'Array of floats' call logger % check_json_value ( json , json_path , json_array , routine = this , line = __ LINE__ , error = error_code ) if ( error_code == 0 ) call json % get ( json_path , float_array ) call json % destroy () if ( rank /= 0 ) dirname = 'file' call logger % check_directory ( dirname , . true ., routine = this , is_fatal = . false ., file = __ FILE__ , line = __ LINE__ ) if ( rank /= 0 ) call execute_command_line ( 'rm -rf ' // dirname ) if ( rank /= 0 ) filename = 'files/file.json' call logger % check_file ( filename , routine = this , is_fatal = . false .) call logger % info ( '***************************************************************' ) call logger % info ( '                  Tests passed...                              ' ) call logger % info ( '***************************************************************' ) end subroutine test_check_json end module test_check_json_m","tags":"","loc":"sourcefile/test_check_json_m.f90.html"},{"title":"test_check_alloc_m.F90 – Fortran Logger","text":"This file depends on sourcefile~~test_check_alloc_m.f90~~EfferentGraph sourcefile~test_check_alloc_m.f90 test_check_alloc_m.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~test_check_alloc_m.f90->sourcefile~fortran_logger.f90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~test_check_alloc_m.f90~~AfferentGraph sourcefile~test_check_alloc_m.f90 test_check_alloc_m.F90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~test_check_alloc_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules test_check_alloc_m Source Code test_check_alloc_m.F90 Source Code module test_check_alloc_m !< Module to test check_alloc generic method of Fortran Logger use fortran_logger , only : fortran_logger_t use penf , only : I1P , I2P , I4P , I8P , R4P , R8P #ifdef _R16P use penf , only : R16P #endif implicit none private public :: test_check_alloc contains subroutine test_check_alloc ( logger ) !< Tester subroutine class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class complex ( R4P ), allocatable :: c14 (:) !< Complex buffer of rank 1, 4 bytes complex ( R4P ), allocatable :: c24 (:,:) !< Complex buffer of rank 2, 4 bytes complex ( R4P ), allocatable :: c34 (:,:,:) !< Complex buffer of rank 3, 4 bytes complex ( R4P ), allocatable :: c44 (:,:,:,:) !< Complex buffer of rank 4, 4 bytes complex ( R8P ), allocatable :: c18 (:) !< Complex buffer of rank 1, 8 bytes complex ( R8P ), allocatable :: c28 (:,:) !< Complex buffer of rank 2, 8 bytes complex ( R8P ), allocatable :: c38 (:,:,:) !< Complex buffer of rank 3, 8 bytes complex ( R8P ), allocatable :: c48 (:,:,:,:) !< Complex buffer of rank 4, 8 bytes #ifdef _R16P complex ( R16P ), allocatable :: c116 (:) !< Complex buffer of rank 1, 16 bytes complex ( R16P ), allocatable :: c216 (:,:) !< Complex buffer of rank 2, 16 bytes complex ( R16P ), allocatable :: c316 (:,:,:) !< Complex buffer of rank 3, 16 bytes complex ( R16P ), allocatable :: c416 (:,:,:,:) !< Complex buffer of rank 4, 16 bytes #endif real ( R4P ), allocatable :: r14 (:) !< Real buffer of rank 1, 4 bytes real ( R4P ), allocatable :: r24 (:,:) !< Real buffer of rank 2, 4 bytes real ( R4P ), allocatable :: r34 (:,:,:) !< Real buffer of rank 3, 4 bytes real ( R4P ), allocatable :: r44 (:,:,:,:) !< Real buffer of rank 4, 4 bytes real ( R8P ), allocatable :: r18 (:) !< Real buffer of rank 1, 8 bytes real ( R8P ), allocatable :: r28 (:,:) !< Real buffer of rank 2, 8 bytes real ( R8P ), allocatable :: r38 (:,:,:) !< Real buffer of rank 3, 8 bytes real ( R8P ), allocatable :: r48 (:,:,:,:) !< Real buffer of rank 4, 8 bytes #ifdef _R16P real ( R16P ), allocatable :: r116 (:) !< Real buffer of rank 1, 16 bytes real ( R16P ), allocatable :: r216 (:,:) !< Real buffer of rank 2, 16 bytes real ( R16P ), allocatable :: r316 (:,:,:) !< Real buffer of rank 3, 16 bytes real ( R16P ), allocatable :: r416 (:,:,:,:) !< Real buffer of rank 4, 16 bytes #endif integer ( I1P ), allocatable :: i11 (:) !< Integer buffer of rank 1, 1 byte integer ( I1P ), allocatable :: i21 (:,:) !< Integer buffer of rank 2, 1 byte integer ( I1P ), allocatable :: i31 (:,:,:) !< Integer buffer of rank 3, 1 byte integer ( I1P ), allocatable :: i41 (:,:,:,:) !< Integer buffer of rank 4, 1 byte integer ( I2P ), allocatable :: i12 (:) !< Integer buffer of rank 1, 2 bytes integer ( I2P ), allocatable :: i22 (:,:) !< Integer buffer of rank 2, 2 bytes integer ( I2P ), allocatable :: i32 (:,:,:) !< Integer buffer of rank 3, 2 bytes integer ( I2P ), allocatable :: i42 (:,:,:,:) !< Integer buffer of rank 4, 2 bytes integer ( I4P ), allocatable :: i14 (:) !< Integer buffer of rank 1, 4 bytes integer ( I4P ), allocatable :: i24 (:,:) !< Integer buffer of rank 2, 4 bytes integer ( I4P ), allocatable :: i34 (:,:,:) !< Integer buffer of rank 3, 4 bytes integer ( I4P ), allocatable :: i44 (:,:,:,:) !< Integer buffer of rank 4, 4 bytes integer ( I8P ), allocatable :: i18 (:) !< Integer buffer of rank 1, 8 bytes integer ( I8P ), allocatable :: i28 (:,:) !< Integer buffer of rank 2, 8 bytes integer ( I8P ), allocatable :: i38 (:,:,:) !< Integer buffer of rank 3, 8 bytes integer ( I8P ), allocatable :: i48 (:,:,:,:) !< Integer buffer of rank 4, 8 bytes integer ( I4P ), parameter :: alloc_size = 5 !< Allocation size character ( len = :), allocatable :: this !< This subroutine name call logger % info ( '***************************************************************' ) call logger % info ( '               Testing \"check alloc\" methods                   ' ) call logger % info ( '***************************************************************' ) this = 'test_check_alloc' call logger % debug ( 'Allocating complex buffer of rank 1 of type R4P...' , routine = this ) allocate ( c14 ( alloc_size )) call logger % check_alloc ( c14 , 'complex_rank_1_R4P' , routine = this ) call logger % debug ( 'Allocating complex buffer of rank 1 of type R8P...' , routine = this ) allocate ( c18 ( alloc_size )) call logger % check_alloc ( c18 , 'complex_rank_1_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating complex buffer of rank 1 of type R16P...' , routine = this ) allocate ( c116 ( alloc_size )) call logger % check_alloc ( c116 , 'complex_rank_1_R16P' , routine = this ) #endif call logger % debug ( 'Allocating complex buffer of rank 2 of type R4P...' , routine = this ) allocate ( c24 ( alloc_size , alloc_size )) call logger % check_alloc ( c24 , 'complex_rank_2_R4P' , routine = this ) call logger % debug ( 'Allocating complex buffer of rank 2 of type R8P...' , routine = this ) allocate ( c28 ( alloc_size , alloc_size )) call logger % check_alloc ( c28 , 'complex_rank_2_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating complex buffer of rank 2 of type R16P...' , routine = this ) allocate ( c216 ( alloc_size , alloc_size )) call logger % check_alloc ( c216 , 'complex_rank_2_R16P' , routine = this ) #endif call logger % debug ( 'Allocating complex buffer of rank 3 of type R4P...' , routine = this ) allocate ( c34 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c34 , 'complex_rank_3_R4P' , routine = this ) call logger % debug ( 'Allocating complex buffer of rank 3 of type R8P...' , routine = this ) allocate ( c38 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c38 , 'complex_rank_3_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating complex buffer of rank 3 of type R16P...' , routine = this ) allocate ( c316 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c316 , 'complex_rank_3_R16P' , routine = this ) #endif call logger % debug ( 'Allocating complex buffer of rank 4 of type R4P...' , routine = this ) allocate ( c44 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c44 , 'complex_rank_4_R4P' , routine = this ) call logger % debug ( 'Allocating complex buffer of rank 4 of type R8P...' , routine = this ) allocate ( c48 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c48 , 'complex_rank_4_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating complex buffer of rank 4 of type R16P...' , routine = this ) allocate ( c416 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( c416 , 'complex_rank_4_R16P' , routine = this ) #endif deallocate ( c14 , c24 , c34 , c44 ) deallocate ( c18 , c28 , c38 , c48 ) #ifdef _R16P deallocate ( c116 , c216 , c316 , c416 ) #endif call logger % debug ( 'Allocating real buffer of rank 1 of type R4P...' , routine = this ) allocate ( r14 ( alloc_size )) call logger % check_alloc ( r14 , 'real_rank_1_R4P' , routine = this ) call logger % debug ( 'Allocating real buffer of rank 1 of type R8P...' , routine = this ) allocate ( r18 ( alloc_size )) call logger % check_alloc ( r18 , 'real_rank_1_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating real buffer of rank 1 of type R16P...' , routine = this ) allocate ( r116 ( alloc_size )) call logger % check_alloc ( r116 , 'real_rank_1_R16P' , routine = this ) #endif call logger % debug ( 'Allocating real buffer of rank 2 of type R4P...' , routine = this ) allocate ( r24 ( alloc_size , alloc_size )) call logger % check_alloc ( r24 , 'real_rank_2_R4P' , routine = this ) call logger % debug ( 'Allocating real buffer of rank 2 of type R8P...' , routine = this ) allocate ( r28 ( alloc_size , alloc_size )) call logger % check_alloc ( r28 , 'real_rank_2_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating real buffer of rank 2 of type R16P...' , routine = this ) allocate ( r216 ( alloc_size , alloc_size )) call logger % check_alloc ( r216 , 'real_rank_2_R16P' , routine = this ) #endif call logger % debug ( 'Allocating real buffer of rank 3 of type R4P...' , routine = this ) allocate ( r34 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r34 , 'real_rank_3_R4P' , routine = this ) call logger % debug ( 'Allocating real buffer of rank 3 of type R8P...' , routine = this ) allocate ( r38 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r38 , 'real_rank_3_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating real buffer of rank 3 of type R16P...' , routine = this ) allocate ( r316 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r316 , 'real_rank_3_R16P' , routine = this ) #endif call logger % debug ( 'Allocating real buffer of rank 4 of type R4P...' , routine = this ) allocate ( r44 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r44 , 'real_rank_4_R4P' , routine = this ) call logger % debug ( 'Allocating real buffer of rank 4 of type R8P...' , routine = this ) allocate ( r48 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r48 , 'real_rank_4_R8P' , routine = this ) #ifdef _R16P call logger % debug ( 'Allocating real buffer of rank 4 of type R16P...' , routine = this ) allocate ( r416 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( r416 , 'real_rank_4_R16P' , routine = this ) #endif deallocate ( r14 , r24 , r34 , r44 ) deallocate ( r18 , r28 , r38 , r48 ) #ifdef _R16P deallocate ( r116 , r216 , r316 , r416 ) #endif call logger % debug ( 'Allocating integer buffer of rank 1 of type I1P...' , routine = this ) allocate ( i11 ( alloc_size )) call logger % check_alloc ( i11 , 'integer_rank_1_I1P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 1 of type I2P...' , routine = this ) allocate ( i12 ( alloc_size )) call logger % check_alloc ( i12 , 'integer_rank_1_I2P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 1 of type I4P...' , routine = this ) allocate ( i14 ( alloc_size )) call logger % check_alloc ( i14 , 'integer_rank_1_I4P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 1 of type I8P...' , routine = this ) allocate ( i18 ( alloc_size )) call logger % check_alloc ( i18 , 'integer_rank_1_I8P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 2 of type I1P...' , routine = this ) allocate ( i21 ( alloc_size , alloc_size )) call logger % check_alloc ( i21 , 'integer_rank_2_I1P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 2 of type I2P...' , routine = this ) allocate ( i22 ( alloc_size , alloc_size )) call logger % check_alloc ( i22 , 'integer_rank_2_I2P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 2 of type I4P...' , routine = this ) allocate ( i24 ( alloc_size , alloc_size )) call logger % check_alloc ( i24 , 'integer_rank_2_I4P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 2 of type I8P...' , routine = this ) allocate ( i28 ( alloc_size , alloc_size )) call logger % check_alloc ( i28 , 'integer_rank_2_I8P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 3 of type I1P...' , routine = this ) allocate ( i31 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i31 , 'integer_rank_3_I1P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 3 of type I2P...' , routine = this ) allocate ( i32 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i31 , 'integer_rank_3_I2P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 3 of type I4P...' , routine = this ) allocate ( i34 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i34 , 'integer_rank_3_I4P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 3 of type I8P...' , routine = this ) allocate ( i38 ( alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i38 , 'integer_rank_3_I8P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 4 of type I1P...' , routine = this ) allocate ( i41 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i41 , 'integer_rank_4_I1P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 4 of type I2P...' , routine = this ) allocate ( i42 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i42 , 'integer_rank_4_I2P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 4 of type I4P...' , routine = this ) allocate ( i44 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i44 , 'integer_rank_4_I4P' , routine = this ) call logger % debug ( 'Allocating integer buffer of rank 4 of type I8P...' , routine = this ) allocate ( i48 ( alloc_size , alloc_size , alloc_size , alloc_size )) call logger % check_alloc ( i48 , 'integer_rank_4_I8P' , routine = this ) deallocate ( i11 , i21 , i31 , i41 ) deallocate ( i12 , i22 , i32 , i42 ) deallocate ( i14 , i24 , i34 , i44 ) deallocate ( i18 , i28 , i38 , i48 ) call logger % info ( '***************************************************************' ) call logger % info ( '                  Tests passed...                              ' ) call logger % info ( '***************************************************************' ) end subroutine test_check_alloc end module test_check_alloc_m","tags":"","loc":"sourcefile/test_check_alloc_m.f90.html"},{"title":"test_ignore_error_codes_m.F90 – Fortran Logger","text":"This file depends on sourcefile~~test_ignore_error_codes_m.f90~~EfferentGraph sourcefile~test_ignore_error_codes_m.f90 test_ignore_error_codes_m.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~test_ignore_error_codes_m.f90->sourcefile~fortran_logger.f90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~test_ignore_error_codes_m.f90~~AfferentGraph sourcefile~test_ignore_error_codes_m.f90 test_ignore_error_codes_m.F90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~test_ignore_error_codes_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules test_ignore_error_codes_m Source Code test_ignore_error_codes_m.F90 Source Code module test_ignore_error_codes_m !< Module to test check_error and ignore_error_codes generic methods of Fortran Logger use fortran_logger , only : fortran_logger_t use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , str #ifdef _R16P use penf , only : R16P #endif implicit none private public :: test_ignore_error_codes interface errored_subroutine !< Generic external subroutines that return non-zero error codes module procedure :: errored_subroutine_I1P module procedure :: errored_subroutine_I2P module procedure :: errored_subroutine_I4P module procedure :: errored_subroutine_I8P module procedure :: errored_subroutine_LOGICAL end interface errored_subroutine contains subroutine test_ignore_error_codes ( logger ) !< Tester subroutine class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I1P ) :: error_code_I1P !< Error code 1 byte integer ( I2P ) :: error_code_I2P !< Error code 2 bytes integer ( I4P ) :: error_code_I4P !< Error code 4 bytes integer ( I8P ) :: error_code_I8P !< Error code 8 bytes logical :: error_code_LOGICAL !< Logical error flag character ( len = :), allocatable :: this !< This subroutine name call logger % info ( '***************************************************************' ) call logger % info ( '               Testing \"ignore error codes\" methods            ' ) call logger % info ( '***************************************************************' ) this = 'test_ignore_error_codes' call errored_subroutine ( logger , error_code_I1P ) call logger % check_error ( 'errored_subroutine_I1P' , error_code_I1P , routine = this , is_fatal = . false .) call logger % ignore_error_codes ([ error_code_I1P ]) call logger % warn ( 'Ignoring code: ' // trim ( str ( error_code_I1P )), routine = this ) call errored_subroutine ( logger , error_code_I1P ) call logger % check_error ( 'errored_subroutine_I1P' , error_code_I1P , routine = this , is_fatal = . false .) call errored_subroutine ( logger , error_code_I2P ) call logger % check_error ( 'errored_subroutine_I2P' , error_code_I2P , routine = this , is_fatal = . false .) call logger % warn ( 'Ignoring code: ' // trim ( str ( error_code_I2P )), routine = this ) call logger % ignore_error_codes ([ error_code_I2P ]) call errored_subroutine ( logger , error_code_I2P ) call logger % check_error ( 'errored_subroutine_I2P' , error_code_I2P , routine = this , is_fatal = . false .) call errored_subroutine ( logger , error_code_I4P ) call logger % check_error ( 'errored_subroutine_I4P' , error_code_I4P , routine = this , is_fatal = . false .) call logger % warn ( 'Ignoring code: ' // trim ( str ( error_code_I4P )), routine = this ) call logger % ignore_error_codes ([ error_code_I4P ]) call errored_subroutine ( logger , error_code_I4P ) call logger % check_error ( 'errored_subroutine_I4P' , error_code_I4P , routine = this , is_fatal = . false .) call errored_subroutine ( logger , error_code_I8P ) call logger % check_error ( 'errored_subroutine_I8P' , error_code_I8P , routine = this , is_fatal = . false .) call logger % warn ( 'Ignoring code: ' // trim ( str ( error_code_I8P )), routine = this ) call logger % ignore_error_codes ([ error_code_I8P ]) call errored_subroutine ( logger , error_code_I8P ) call logger % check_error ( 'errored_subroutine_I8P' , error_code_I8P , routine = this , is_fatal = . false .) call errored_subroutine ( logger , error_code_LOGICAL ) call logger % check_error ( 'errored_subroutine_LOGICAL' , error_code_LOGICAL , routine = this , is_fatal = . false .) ! there is no way to ignore logical error code call logger % info ( '***************************************************************' ) call logger % info ( '                  Tests passed...                              ' ) call logger % info ( '***************************************************************' ) end subroutine test_ignore_error_codes subroutine errored_subroutine_I1P ( logger , error ) !< Dummy external subroutine that returns non-zero error code, 1 byte class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I1P ), intent ( out ) :: error !< Error code call logger % debug ( 'Entering...' , routine = 'errored_subroutine_I1P' ) error = - 1_I1P call logger % debug ( 'Exiting...' , routine = 'errored_subroutine_I1P' ) end subroutine errored_subroutine_I1P subroutine errored_subroutine_I2P ( logger , error ) !< Dummy external subroutine that returns non-zero error code, 2 bytes class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I2P ), intent ( out ) :: error !< Error code call logger % debug ( 'Entering...' , routine = 'errored_subroutine_I2P' ) error = - 2_I2P call logger % debug ( 'Exiting...' , routine = 'errored_subroutine_I2P' ) end subroutine errored_subroutine_I2P subroutine errored_subroutine_I4P ( logger , error ) !< Dummy external subroutine that returns non-zero error code, 4 bytes class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I4P ), intent ( out ) :: error !< Error code call logger % debug ( 'Entering...' , routine = 'errored_subroutine_I4P' ) error = - 4_I4P call logger % debug ( 'Exiting...' , routine = 'errored_subroutine_I4P' ) end subroutine errored_subroutine_I4P subroutine errored_subroutine_I8P ( logger , error ) !< Dummy external subroutine that returns non-zero error code, 8 bytes class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I8P ), intent ( out ) :: error !< Error code call logger % debug ( 'Entering...' , routine = 'errored_subroutine_I8P' ) error = - 8_I8P call logger % debug ( 'Exiting...' , routine = 'errored_subroutine_I8P' ) end subroutine errored_subroutine_I8P subroutine errored_subroutine_LOGICAL ( logger , error ) !< Dummy external subroutine that returns logical False status class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class logical , intent ( out ) :: error !< Error code call logger % debug ( 'Entering...' , routine = 'errored_subroutine_LOGICAL' ) error = . false . call logger % debug ( 'Exiting...' , routine = 'errored_subroutine_LOGICAL' ) end subroutine errored_subroutine_LOGICAL end module test_ignore_error_codes_m","tags":"","loc":"sourcefile/test_ignore_error_codes_m.f90.html"},{"title":"test_unit_change_m.F90 – Fortran Logger","text":"This file depends on sourcefile~~test_unit_change_m.f90~~EfferentGraph sourcefile~test_unit_change_m.f90 test_unit_change_m.F90 sourcefile~fortran_logger.f90 fortran_logger.F90 sourcefile~test_unit_change_m.f90->sourcefile~fortran_logger.f90 sourcefile~logger_element_object.f90 logger_element_object.F90 sourcefile~fortran_logger.f90->sourcefile~logger_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~test_unit_change_m.f90~~AfferentGraph sourcefile~test_unit_change_m.f90 test_unit_change_m.F90 sourcefile~run_tests.f90 run_tests.F90 sourcefile~run_tests.f90->sourcefile~test_unit_change_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules test_unit_change_m Source Code test_unit_change_m.F90 Source Code module test_unit_change_m !< Module to test change_unit method of Fortran Logger use fortran_logger , only : fortran_logger_t , LOGGER_DEBUG_LEVEL use penf , only : I4P , str use iso_fortran_env , only : output_unit implicit none private public :: test_unit_change contains subroutine test_unit_change ( logger , rank , np , null_unit ) !< Tester subroutine class ( fortran_logger_t ), intent ( inout ) :: logger !< Fortran logger class integer ( I4P ), intent ( in ) :: rank !< MPI rank integer ( I4P ), intent ( in ) :: np !< MPI size integer ( I4P ), intent ( in ) :: null_unit !< /dev/null unit integer ( I4P ) :: r !< Counter integer ( I4P ) :: out_unit !< Output unit call logger % info ( '***************************************************************' ) call logger % info ( '               Testing \"change_unit\" method                    ' ) call logger % info ( '***************************************************************' ) do r = 0 , np - 1 out_unit = null_unit ; if ( rank == r ) out_unit = output_unit call logger % change_unit ( LOGGER_DEBUG_LEVEL , out_unit ) call logger % debug ( 'This message was generated by rank = ' // trim ( str ( n = rank , no_sign = . true .)), routine = 'test_unit_change' ) enddo ! Restore unit out_unit = null_unit ; if ( rank == 0 ) out_unit = output_unit call logger % change_unit ( LOGGER_DEBUG_LEVEL , out_unit ) call logger % info ( '***************************************************************' ) call logger % info ( '                  Tests passed...                              ' ) call logger % info ( '***************************************************************' ) end subroutine test_unit_change end module test_unit_change_m","tags":"","loc":"sourcefile/test_unit_change_m.f90.html"},{"title":"element_object – Fortran Logger ","text":"type, public :: element_object Definition of Object Class Inherited by type~~element_object~~InheritedByGraph type~element_object element_object type~fortran_logger_t fortran_logger_t type~fortran_logger_t->type~element_object logger_object, timestamp_object, routine_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables out_unit string color_fg color_bg style prefix suffix Type-Bound Procedures finalize initialize output update_unit get_unit Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: out_unit Unit used to print output character(len=:), private, allocatable :: string Element string character(len=:), private, allocatable :: color_fg Foreground color character(len=:), private, allocatable :: color_bg Background color character(len=:), private, allocatable :: style Style character(len=:), private, allocatable :: prefix Prefix string character(len=:), private, allocatable :: suffix Suffix string Type-Bound Procedures procedure, public, pass(self) :: finalize Finalize element private pure subroutine finalize (self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element procedure, public, pass(self) :: initialize Initialize element private pure subroutine initialize (self, out_unit, string, color_fg, color_bg, style, prefix, suffix) Initialization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in), optional :: out_unit Unit used to print output character(len=*), intent(in), optional :: string Element string character(len=*), intent(in), optional :: color_fg Foreground color character(len=*), intent(in), optional :: color_bg Background color character(len=*), intent(in), optional :: style Style character(len=*), intent(in), optional :: prefix Prefix string character(len=*), intent(in), optional :: suffix Suffix string procedure, public, pass(self) :: output Return formatted output of element private function output (self, update_string) Generate output message Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element character(len=*), intent(in), optional :: update_string Element string Return Value character(len=:),\n  allocatable Formatted output. procedure, public, pass(self) :: update_unit Replace current out_unit with new one private pure subroutine update_unit (self, new_unit) Changes current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in) :: new_unit New output unit number procedure, public, pass(self) :: get_unit Return current out_unit private pure function get_unit (self) result(unit) Returns current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self Element Return Value integer(kind=I4P) Output unit","tags":"","loc":"type/element_object.html"},{"title":"fortran_logger_t – Fortran Logger ","text":"type, public :: fortran_logger_t Definition of Logger class Inherits type~~fortran_logger_t~~InheritsGraph type~fortran_logger_t fortran_logger_t MPI_Comm MPI_Comm type~fortran_logger_t->MPI_Comm comm type~element_object element_object type~fortran_logger_t->type~element_object logger_object, timestamp_object, routine_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables log_level logger_object timestamp_object routine_object print_timestamp timestamp_format ignored_codes gather_buf comm Type-Bound Procedures finalize initialize error warn info debug change_unit check_json_value check_directory check_file check_error check_alloc ignore_error_codes check_error_LOGICAL check_error_I1P check_error_I2P check_error_I4P check_error_I8P check_alloc_rank1_CR4P check_alloc_rank1_CR8P check_alloc_rank1_CR16P check_alloc_rank2_CR4P check_alloc_rank2_CR8P check_alloc_rank2_CR16P check_alloc_rank3_CR4P check_alloc_rank3_CR8P check_alloc_rank3_CR16P check_alloc_rank4_CR4P check_alloc_rank4_CR8P check_alloc_rank4_CR16P check_alloc_rank1_R4P check_alloc_rank1_R8P check_alloc_rank1_R16P check_alloc_rank2_R4P check_alloc_rank2_R8P check_alloc_rank2_R16P check_alloc_rank3_R4P check_alloc_rank3_R8P check_alloc_rank3_R16P check_alloc_rank4_R4P check_alloc_rank4_R8P check_alloc_rank4_R16P check_alloc_rank1_I1P check_alloc_rank1_I2P check_alloc_rank1_I4P check_alloc_rank1_I8P check_alloc_rank2_I1P check_alloc_rank2_I2P check_alloc_rank2_I4P check_alloc_rank2_I8P check_alloc_rank3_I1P check_alloc_rank3_I2P check_alloc_rank3_I4P check_alloc_rank3_I8P check_alloc_rank4_I1P check_alloc_rank4_I2P check_alloc_rank4_I4P check_alloc_rank4_I8P ignore_error_codes_I1P ignore_error_codes_I2P ignore_error_codes_I4P ignore_error_codes_I8P gather_error_codes print Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: log_level Level of logging type( element_object ), private :: logger_object (4) Objects that handle messages from all levels type( element_object ), private :: timestamp_object Timestamp handle type( element_object ), private :: routine_object Handle of optional “routine” parameter in most of methods logical, private :: print_timestamp Timestamp printer flag character(len=:), private, allocatable :: timestamp_format Timestamp format, C style integer(kind=I4P), private, allocatable :: ignored_codes (:) Buffer that keeps all ignored codes integer(kind=I4P), private, allocatable :: gather_buf (:) Buffer that aggregates all error codes type(MPI_Comm), private :: comm MPI Communicator Type-Bound Procedures procedure, public, pass(self) :: finalize Finalization class subroutine private subroutine finalize (self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger procedure, public, pass(self) :: initialize Initialization class subroutine private subroutine initialize (self, comm, log_level, error_unit, error_color_fg, error_color_bg, error_style, error_prefix, error_suffix, warn_unit, warn_color_fg, warn_color_bg, warn_style, warn_prefix, warn_suffix, info_unit, info_color_fg, info_color_bg, info_style, info_prefix, info_suffix, debug_unit, debug_color_fg, debug_color_bg, debug_style, debug_prefix, debug_suffix, routine_prefix, routine_suffix, print_timestamp, timestamp_format, timestamp_color_fg, timestamp_color_bg, timestamp_style, timestamp_prefix, timestamp_suffix) Initialization class subroutine If built with MPI support then MPI_Init must be called before calling this method Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=I4P), intent(in), optional :: log_level Level of logging integer(kind=I4P), intent(in), optional :: error_unit Unit used to print ERROR messages character(len=*), intent(in), optional :: error_color_fg ERROR foreground color character(len=*), intent(in), optional :: error_color_bg ERROR background color character(len=*), intent(in), optional :: error_style ERROR style character(len=*), intent(in), optional :: error_prefix ERROR prefix character(len=*), intent(in), optional :: error_suffix ERROR suffix integer(kind=I4P), intent(in), optional :: warn_unit Unit used to print WARN messages character(len=*), intent(in), optional :: warn_color_fg WARN foreground color character(len=*), intent(in), optional :: warn_color_bg WARN background color character(len=*), intent(in), optional :: warn_style WARN style character(len=*), intent(in), optional :: warn_prefix WARN prefix character(len=*), intent(in), optional :: warn_suffix WARN suffix integer(kind=I4P), intent(in), optional :: info_unit Unit used to print INFO messages character(len=*), intent(in), optional :: info_color_fg INFO foreground color character(len=*), intent(in), optional :: info_color_bg INFO background color character(len=*), intent(in), optional :: info_style INFO style character(len=*), intent(in), optional :: info_prefix INFO prefix character(len=*), intent(in), optional :: info_suffix INFO suffix integer(kind=I4P), intent(in), optional :: debug_unit Unit used to print DEBUG messages character(len=*), intent(in), optional :: debug_color_fg DEBUG foreground color character(len=*), intent(in), optional :: debug_color_bg DEBUG background color character(len=*), intent(in), optional :: debug_style DEBUG style character(len=*), intent(in), optional :: debug_prefix DEBUG prefix character(len=*), intent(in), optional :: debug_suffix DEBUG suffix character(len=*), intent(in), optional :: routine_prefix Routine prefix. routine is optional agrument in most of logger methods character(len=*), intent(in), optional :: routine_suffix Routine suffix. routine is optional agrument in most of logger methods logical, intent(in), optional :: print_timestamp Display current timestamp with all messages. Default is .true. character(len=*), intent(in), optional :: timestamp_format Timestamp format, C style character(len=*), intent(in), optional :: timestamp_color_fg Timestamp foreground color character(len=*), intent(in), optional :: timestamp_color_bg Timestamp background color character(len=*), intent(in), optional :: timestamp_style Timestamp style character(len=*), intent(in), optional :: timestamp_prefix Timestamp prefix character(len=*), intent(in), optional :: timestamp_suffix Timestamp suffix procedure, public, pass(self) :: error Print error message private subroutine error (self, message, routine, file, line, error_code, errored_rank, is_fatal) Will print error message if current logging level >= LOGGER_ERROR_LEVEL . If is_fatal = .true., program will stop execution. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error was called, e.g. __LINE__ integer(kind=I4P), intent(in), optional :: error_code Internal subroutine returned error code integer(kind=I4P), intent(in), optional :: errored_rank Rank where error occured logical, intent(in), optional :: is_fatal Fatal error. Default is .false. procedure, public, pass(self) :: warn Print warn message private subroutine warn (self, message, routine, file, line) Will print warn message if current logging level >= LOGGER_WARN_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where warn was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where warn was called, e.g. __LINE__ procedure, public, pass(self) :: info Print info message private subroutine info (self, message, routine, file, line) Will print info message if current logging level >= LOGGER_INFO_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where info was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where info was called, e.g. __LINE__ procedure, public, pass(self) :: debug Print debug message private subroutine debug (self, message, routine, file, line) Will print debug message if current logging level = LOGGER_DEBUG_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where debug was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where debug was called, e.g. __LINE__ procedure, public, pass(self) :: change_unit Runtime output unit change private subroutine change_unit (self, log_level, new_unit) Will change output unit for the specified logging level Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: log_level Logging level integer(kind=I4P), intent(in) :: new_unit New output unit for specified log_level procedure, public, pass(self) :: check_json_value Checks presence and type of value in json file private subroutine check_json_value (self, json, json_path, expected_type, routine, is_fatal, file, line, error) Checks presence and type of value in json file Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger class(json_file), intent(inout) :: json JSON handle character(len=*), intent(in) :: json_path Path to variable integer(kind=I4P), intent(in) :: expected_type Expected variable datatype character(len=*), intent(in), optional :: routine Internal subroutine name logical, intent(in), optional :: is_fatal Fatal error. Default is .false. character(len=*), intent(in), optional :: file Source file name where json is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where json is being checked, e.g. __LINE__ integer(kind=I4P), intent(out), optional :: error Error code procedure, public, pass(self) :: check_directory Checks directory presence private subroutine check_directory (self, dir_path, is_create, routine, file, line, is_fatal, error) Checks directory presence in the specified path If directory doesn’t exist, logger can create it. Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: dir_path Path to directory logical, intent(in) :: is_create Create directory if it doesn’t exist character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code procedure, public, pass(self) :: check_file Checks file presence private subroutine check_file (self, file_path, routine, file, line, is_fatal, error) Checks file presence in the specified path\n Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: file_path Path to directory character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code generic, public :: check_error => check_error_LOGICAL , check_error_I1P , check_error_I2P , check_error_I4P , check_error_I8P Checks error code returned by external subroutine. private subroutine check_error_LOGICAL (self, check_routine, error_code, routine, file, line, is_fatal) Checks logical error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast logical, intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. Default is .false. private subroutine check_error_I1P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I1P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I1P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I2P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I2P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I2P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I4P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I4P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I4P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I8P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I8P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I8P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. generic, public :: check_alloc => check_alloc_rank1_CR4P , check_alloc_rank1_CR8P , check_alloc_rank1_CR16P , check_alloc_rank2_CR4P , check_alloc_rank2_CR8P , check_alloc_rank2_CR16P , check_alloc_rank3_CR4P , check_alloc_rank3_CR8P , check_alloc_rank3_CR16P , check_alloc_rank4_CR4P , check_alloc_rank4_CR8P , check_alloc_rank4_CR16P , check_alloc_rank1_R4P , check_alloc_rank1_R8P , check_alloc_rank1_R16P , check_alloc_rank2_R4P , check_alloc_rank2_R8P , check_alloc_rank2_R16P , check_alloc_rank3_R4P , check_alloc_rank3_R8P , check_alloc_rank3_R16P , check_alloc_rank4_R4P , check_alloc_rank4_R8P , check_alloc_rank4_R16P , check_alloc_rank1_I1P , check_alloc_rank1_I2P , check_alloc_rank1_I4P , check_alloc_rank1_I8P , check_alloc_rank2_I1P , check_alloc_rank2_I2P , check_alloc_rank2_I4P , check_alloc_rank2_I8P , check_alloc_rank3_I1P , check_alloc_rank3_I2P , check_alloc_rank3_I4P , check_alloc_rank3_I8P , check_alloc_rank4_I1P , check_alloc_rank4_I2P , check_alloc_rank4_I4P , check_alloc_rank4_I8P Checks allocation of buffers of different types and ranks private subroutine check_alloc_rank1_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ generic, public :: ignore_error_codes => ignore_error_codes_I1P , ignore_error_codes_I2P , ignore_error_codes_I4P , ignore_error_codes_I8P Ignore codes of various types except logical private subroutine ignore_error_codes_I1P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I1P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I2P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I2P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I4P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I4P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I8P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I8P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger procedure, private, pass(self) :: check_error_LOGICAL Checks logical error_code returned by external subroutine. private subroutine check_error_LOGICAL (self, check_routine, error_code, routine, file, line, is_fatal) Checks logical error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast logical, intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. Default is .false. procedure, private, pass(self) :: check_error_I1P Checks integer I1P error_code returned by external subroutine. private subroutine check_error_I1P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I1P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I1P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. procedure, private, pass(self) :: check_error_I2P Checks integer I2P error_code returned by external subroutine. private subroutine check_error_I2P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I2P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I2P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. procedure, private, pass(self) :: check_error_I4P Checks integer I4P error_code returned by external subroutine. private subroutine check_error_I4P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I4P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I4P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. procedure, private, pass(self) :: check_error_I8P Checks integer I8P error_code returned by external subroutine. private subroutine check_error_I8P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I8P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I8P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. procedure, private, pass(self) :: check_alloc_rank1_CR4P Checks allocation of complex R4P buffer of rank = 1 private subroutine check_alloc_rank1_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_CR8P Checks allocation of complex R8P buffer of rank = 1 private subroutine check_alloc_rank1_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_CR16P Checks allocation of complex R16P buffer of rank = 1 private subroutine check_alloc_rank1_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_CR4P Checks allocation of complex R4P buffer of rank = 2 private subroutine check_alloc_rank2_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_CR8P Checks allocation of complex R8P buffer of rank = 2 private subroutine check_alloc_rank2_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_CR16P Checks allocation of complex R16P buffer of rank = 2 private subroutine check_alloc_rank2_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_CR4P Checks allocation of complex R4P buffer of rank = 3 private subroutine check_alloc_rank3_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_CR8P Checks allocation of complex R8P buffer of rank = 3 private subroutine check_alloc_rank3_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_CR16P Checks allocation of complex R16P buffer of rank = 3 private subroutine check_alloc_rank3_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_CR4P Checks allocation of complex R4P buffer of rank = 4 private subroutine check_alloc_rank4_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_CR8P Checks allocation of complex R8P buffer of rank = 4 private subroutine check_alloc_rank4_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_CR16P Checks allocation of complex R16P buffer of rank = 4 private subroutine check_alloc_rank4_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_R4P Checks allocation of real R4P buffer of rank = 1 private subroutine check_alloc_rank1_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_R8P Checks allocation of real R8P buffer of rank = 1 private subroutine check_alloc_rank1_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_R16P Checks allocation of real R16P buffer of rank = 1 private subroutine check_alloc_rank1_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_R4P Checks allocation of real R4P buffer of rank = 2 private subroutine check_alloc_rank2_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_R8P Checks allocation of real R8P buffer of rank = 2 private subroutine check_alloc_rank2_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_R16P Checks allocation of real R16P buffer of rank = 2 private subroutine check_alloc_rank2_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_R4P Checks allocation of real R4P buffer of rank = 3 private subroutine check_alloc_rank3_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_R8P Checks allocation of real R8P buffer of rank = 3 private subroutine check_alloc_rank3_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_R16P Checks allocation of real R16P buffer of rank = 3 private subroutine check_alloc_rank3_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_R4P Checks allocation of real R4P buffer of rank = 4 private subroutine check_alloc_rank4_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_R8P Checks allocation of real R8P buffer of rank = 4 private subroutine check_alloc_rank4_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_R16P Checks allocation of real R16P buffer of rank = 4 private subroutine check_alloc_rank4_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_I1P Checks allocation of integer I1P buffer of rank = 1 private subroutine check_alloc_rank1_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_I2P Checks allocation of integer I2P buffer of rank = 1 private subroutine check_alloc_rank1_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_I4P Checks allocation of integer I4P buffer of rank = 1 private subroutine check_alloc_rank1_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank1_I8P Checks allocation of integer I8P buffer of rank = 1 private subroutine check_alloc_rank1_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_I1P Checks allocation of integer I1P buffer of rank = 2 private subroutine check_alloc_rank2_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_I2P Checks allocation of integer I2P buffer of rank = 2 private subroutine check_alloc_rank2_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_I4P Checks allocation of integer I4P buffer of rank = 2 private subroutine check_alloc_rank2_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank2_I8P Checks allocation of integer I8P buffer of rank = 2 private subroutine check_alloc_rank2_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_I1P Checks allocation of integer I1P buffer of rank = 3 private subroutine check_alloc_rank3_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_I2P Checks allocation of integer I2P buffer of rank = 3 private subroutine check_alloc_rank3_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_I4P Checks allocation of integer I4P buffer of rank = 3 private subroutine check_alloc_rank3_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank3_I8P Checks allocation of integer I8P buffer of rank = 3 private subroutine check_alloc_rank3_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_I1P Checks allocation of integer I1P buffer of rank = 4 private subroutine check_alloc_rank4_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_I2P Checks allocation of integer I2P buffer of rank = 4 private subroutine check_alloc_rank4_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_I4P Checks allocation of integer I4P buffer of rank = 4 private subroutine check_alloc_rank4_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: check_alloc_rank4_I8P Checks allocation of integer I8P buffer of rank = 4 private subroutine check_alloc_rank4_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ procedure, private, pass(self) :: ignore_error_codes_I1P Ignore codes type I1P private subroutine ignore_error_codes_I1P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I1P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger procedure, private, pass(self) :: ignore_error_codes_I2P Ignore codes type I2P private subroutine ignore_error_codes_I2P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I2P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger procedure, private, pass(self) :: ignore_error_codes_I4P Ignore codes type I4P private subroutine ignore_error_codes_I4P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I4P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger procedure, private, pass(self) :: ignore_error_codes_I8P Ignore codes type I8P private subroutine ignore_error_codes_I8P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I8P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger procedure, private, pass(self) :: gather_error_codes Gather error codes from all processes private subroutine gather_error_codes (self, message, error_code, routine, file, line, is_fatal, gathered_code) Gather error codes from all processes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed class(*), intent(in) :: error_code Internal subroutine returned error code character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error might have occured, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error might have occured, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: gathered_code Aggregated error code similar on all processes. procedure, private, pass(self) :: print Print messages to specified unit private subroutine print (self, level, message, routine, line, file, error_code, rank) Logger printer Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: level Level of the message character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name integer(kind=I4P), intent(in), optional :: line Source file line character(len=*), intent(in), optional :: file Source file name integer(kind=I4P), intent(in), optional :: error_code Occured error code integer(kind=I4P), intent(in), optional :: rank MPI rank","tags":"","loc":"type/fortran_logger_t.html"},{"title":"output – Fortran Logger","text":"private function output(self, update_string) Generate output message Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element character(len=*), intent(in), optional :: update_string Element string Return Value character(len=:),\n  allocatable Formatted output. Calls proc~~output~~CallsGraph proc~output output colorize colorize proc~output->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output.html"},{"title":"get_unit – Fortran Logger","text":"private pure function get_unit(self) result(unit) Returns current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self Element Return Value integer(kind=I4P) Output unit Contents None","tags":"","loc":"proc/get_unit.html"},{"title":"finalize – Fortran Logger","text":"private pure subroutine finalize(self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element Contents None","tags":"","loc":"proc/finalize.html"},{"title":"initialize – Fortran Logger","text":"private pure subroutine initialize(self, out_unit, string, color_fg, color_bg, style, prefix, suffix) Initialization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in), optional :: out_unit Unit used to print output character(len=*), intent(in), optional :: string Element string character(len=*), intent(in), optional :: color_fg Foreground color character(len=*), intent(in), optional :: color_bg Background color character(len=*), intent(in), optional :: style Style character(len=*), intent(in), optional :: prefix Prefix string character(len=*), intent(in), optional :: suffix Suffix string Contents None","tags":"","loc":"proc/initialize.html"},{"title":"update_unit – Fortran Logger","text":"private pure subroutine update_unit(self, new_unit) Changes current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in) :: new_unit New output unit number Contents None","tags":"","loc":"proc/update_unit.html"},{"title":"finalize – Fortran Logger","text":"private subroutine finalize(self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger Contents None","tags":"","loc":"proc/finalize~2.html"},{"title":"initialize – Fortran Logger","text":"private subroutine initialize(self, comm, log_level, error_unit, error_color_fg, error_color_bg, error_style, error_prefix, error_suffix, warn_unit, warn_color_fg, warn_color_bg, warn_style, warn_prefix, warn_suffix, info_unit, info_color_fg, info_color_bg, info_style, info_prefix, info_suffix, debug_unit, debug_color_fg, debug_color_bg, debug_style, debug_prefix, debug_suffix, routine_prefix, routine_suffix, print_timestamp, timestamp_format, timestamp_color_fg, timestamp_color_bg, timestamp_style, timestamp_prefix, timestamp_suffix) Initialization class subroutine If built with MPI support then MPI_Init must be called before calling this method Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=I4P), intent(in), optional :: log_level Level of logging integer(kind=I4P), intent(in), optional :: error_unit Unit used to print ERROR messages character(len=*), intent(in), optional :: error_color_fg ERROR foreground color character(len=*), intent(in), optional :: error_color_bg ERROR background color character(len=*), intent(in), optional :: error_style ERROR style character(len=*), intent(in), optional :: error_prefix ERROR prefix character(len=*), intent(in), optional :: error_suffix ERROR suffix integer(kind=I4P), intent(in), optional :: warn_unit Unit used to print WARN messages character(len=*), intent(in), optional :: warn_color_fg WARN foreground color character(len=*), intent(in), optional :: warn_color_bg WARN background color character(len=*), intent(in), optional :: warn_style WARN style character(len=*), intent(in), optional :: warn_prefix WARN prefix character(len=*), intent(in), optional :: warn_suffix WARN suffix integer(kind=I4P), intent(in), optional :: info_unit Unit used to print INFO messages character(len=*), intent(in), optional :: info_color_fg INFO foreground color character(len=*), intent(in), optional :: info_color_bg INFO background color character(len=*), intent(in), optional :: info_style INFO style character(len=*), intent(in), optional :: info_prefix INFO prefix character(len=*), intent(in), optional :: info_suffix INFO suffix integer(kind=I4P), intent(in), optional :: debug_unit Unit used to print DEBUG messages character(len=*), intent(in), optional :: debug_color_fg DEBUG foreground color character(len=*), intent(in), optional :: debug_color_bg DEBUG background color character(len=*), intent(in), optional :: debug_style DEBUG style character(len=*), intent(in), optional :: debug_prefix DEBUG prefix character(len=*), intent(in), optional :: debug_suffix DEBUG suffix character(len=*), intent(in), optional :: routine_prefix Routine prefix. routine is optional agrument in most of logger methods character(len=*), intent(in), optional :: routine_suffix Routine suffix. routine is optional agrument in most of logger methods logical, intent(in), optional :: print_timestamp Display current timestamp with all messages. Default is .true. character(len=*), intent(in), optional :: timestamp_format Timestamp format, C style character(len=*), intent(in), optional :: timestamp_color_fg Timestamp foreground color character(len=*), intent(in), optional :: timestamp_color_bg Timestamp background color character(len=*), intent(in), optional :: timestamp_style Timestamp style character(len=*), intent(in), optional :: timestamp_prefix Timestamp prefix character(len=*), intent(in), optional :: timestamp_suffix Timestamp suffix Calls proc~~initialize~2~~CallsGraph proc~initialize~2 initialize str str proc~initialize~2->str mpi_comm_size mpi_comm_size proc~initialize~2->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize~2.html"},{"title":"ignore_error_codes_I1P – Fortran Logger","text":"private subroutine ignore_error_codes_I1P(self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I1P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ) :: status , ignored_code call logger % initialize () ignored_code = 33_I1P call logger % ignore_error_codes ([ ignored_code ]) call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) ! If status /= 0 AND ignored_code == status, then no message will be displayed Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger Contents None","tags":"","loc":"proc/ignore_error_codes_i1p.html"},{"title":"ignore_error_codes_I2P – Fortran Logger","text":"private subroutine ignore_error_codes_I2P(self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I2P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ) :: status , ignored_code call logger % initialize () ignored_code = 33_I2P call logger % ignore_error_codes ([ ignored_code ]) call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) ! If status /= 0 AND ignored_code == status, then no message will be displayed Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger Contents None","tags":"","loc":"proc/ignore_error_codes_i2p.html"},{"title":"ignore_error_codes_I4P – Fortran Logger","text":"private subroutine ignore_error_codes_I4P(self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I4P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ) :: status , ignored_code call logger % initialize () ignored_code = 33_I4P call logger % ignore_error_codes ([ ignored_code ]) call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) ! If status /= 0 AND ignored_code == status, then no message will be displayed Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger Contents None","tags":"","loc":"proc/ignore_error_codes_i4p.html"},{"title":"ignore_error_codes_I8P – Fortran Logger","text":"private subroutine ignore_error_codes_I8P(self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I8P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ) :: status , ignored_code call logger % initialize () ignored_code = 33_I8P call logger % ignore_error_codes ([ ignored_code ]) call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) ! If status /= 0 AND ignored_code == status, then no message will be displayed Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger Contents None","tags":"","loc":"proc/ignore_error_codes_i8p.html"},{"title":"change_unit – Fortran Logger","text":"private subroutine change_unit(self, log_level, new_unit) Will change output unit for the specified logging level Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: log_level Logging level integer(kind=I4P), intent(in) :: new_unit New output unit for specified log_level Calls proc~~change_unit~~CallsGraph proc~change_unit change_unit str str proc~change_unit->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/change_unit.html"},{"title":"debug – Fortran Logger","text":"private subroutine debug(self, message, routine, file, line) Will print debug message if current logging level = LOGGER_DEBUG_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where debug was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where debug was called, e.g. __LINE__ Contents None","tags":"","loc":"proc/debug.html"},{"title":"info – Fortran Logger","text":"private subroutine info(self, message, routine, file, line) Will print info message if current logging level >= LOGGER_INFO_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where info was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where info was called, e.g. __LINE__ Contents None","tags":"","loc":"proc/info.html"},{"title":"warn – Fortran Logger","text":"private subroutine warn(self, message, routine, file, line) Will print warn message if current logging level >= LOGGER_WARN_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where warn was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where warn was called, e.g. __LINE__ Contents None","tags":"","loc":"proc/warn.html"},{"title":"error – Fortran Logger","text":"private subroutine error(self, message, routine, file, line, error_code, errored_rank, is_fatal) Will print error message if current logging level >= LOGGER_ERROR_LEVEL . If is_fatal = .true., program will stop execution. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error was called, e.g. __LINE__ integer(kind=I4P), intent(in), optional :: error_code Internal subroutine returned error code integer(kind=I4P), intent(in), optional :: errored_rank Rank where error occured logical, intent(in), optional :: is_fatal Fatal error. Default is .false. Calls proc~~error~~CallsGraph proc~error error mpi_finalize mpi_finalize proc~error->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/error.html"},{"title":"gather_error_codes – Fortran Logger","text":"private subroutine gather_error_codes(self, message, error_code, routine, file, line, is_fatal, gathered_code) Gather error codes from all processes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed class(*), intent(in) :: error_code Internal subroutine returned error code character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error might have occured, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error might have occured, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: gathered_code Aggregated error code similar on all processes. Calls proc~~gather_error_codes~~CallsGraph proc~gather_error_codes gather_error_codes mpi_allgather mpi_allgather proc~gather_error_codes->mpi_allgather mpi_bcast mpi_bcast proc~gather_error_codes->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gather_error_codes.html"},{"title":"check_json_value – Fortran Logger","text":"private subroutine check_json_value(self, json, json_path, expected_type, routine, is_fatal, file, line, error) Checks presence and type of value in json file use json_module , only : json_file , json_string use fortran_logger use penf type ( fortran_logger_t ) :: logger type ( json_file ) :: json character ( len = :), allocatable :: json_path integer ( I4P ) :: error call logger % initialize () call json % load_file ( 'my_config.json' ) json_path = 'logger.test.check_json_value' call logger % check_json_value ( json , json_path , json_string , error = error ) if ( error == 0 ) call json % get ( json_path , success ) call json % destroy () call logger % finalize () Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger class(json_file), intent(inout) :: json JSON handle character(len=*), intent(in) :: json_path Path to variable integer(kind=I4P), intent(in) :: expected_type Expected variable datatype character(len=*), intent(in), optional :: routine Internal subroutine name logical, intent(in), optional :: is_fatal Fatal error. Default is .false. character(len=*), intent(in), optional :: file Source file name where json is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where json is being checked, e.g. __LINE__ integer(kind=I4P), intent(out), optional :: error Error code Calls proc~~check_json_value~~CallsGraph proc~check_json_value check_json_value colorize colorize proc~check_json_value->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_json_value.html"},{"title":"check_directory – Fortran Logger","text":"private subroutine check_directory(self, dir_path, is_create, routine, file, line, is_fatal, error) Checks directory presence in the specified path If directory doesn’t exist, logger can create it. Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: dir_path Path to directory logical, intent(in) :: is_create Create directory if it doesn’t exist character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code Contents None","tags":"","loc":"proc/check_directory.html"},{"title":"check_file – Fortran Logger","text":"private subroutine check_file(self, file_path, routine, file, line, is_fatal, error) Checks file presence in the specified path\n Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: file_path Path to directory character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code Contents None","tags":"","loc":"proc/check_file.html"},{"title":"check_error_LOGICAL – Fortran Logger","text":"private subroutine check_error_LOGICAL(self, check_routine, error_code, routine, file, line, is_fatal) Checks logical error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger logical :: status call logger % initialize () call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast logical, intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. Default is .false. Contents None","tags":"","loc":"proc/check_error_logical.html"},{"title":"check_error_I1P – Fortran Logger","text":"private subroutine check_error_I1P(self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I1P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ) :: status call logger % initialize () call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I1P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. Contents None","tags":"","loc":"proc/check_error_i1p.html"},{"title":"check_error_I2P – Fortran Logger","text":"private subroutine check_error_I2P(self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I2P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ) :: status call logger % initialize () call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I2P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. Contents None","tags":"","loc":"proc/check_error_i2p.html"},{"title":"check_error_I4P – Fortran Logger","text":"private subroutine check_error_I4P(self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I4P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ) :: status call logger % initialize () call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I4P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. Contents None","tags":"","loc":"proc/check_error_i4p.html"},{"title":"check_error_I8P – Fortran Logger","text":"private subroutine check_error_I8P(self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I8P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ) :: status call logger % initialize () call external_subroutine (.., status ) call logger % check_error ( 'external_subroutine' , status ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I8P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. Contents None","tags":"","loc":"proc/check_error_i8p.html"},{"title":"check_alloc_rank1_CR4P – Fortran Logger","text":"private subroutine check_alloc_rank1_CR4P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R4P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_cr4p.html"},{"title":"check_alloc_rank1_CR8P – Fortran Logger","text":"private subroutine check_alloc_rank1_CR8P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R8P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_cr8p.html"},{"title":"check_alloc_rank1_CR16P – Fortran Logger","text":"private subroutine check_alloc_rank1_CR16P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R16P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_cr16p.html"},{"title":"check_alloc_rank2_CR4P – Fortran Logger","text":"private subroutine check_alloc_rank2_CR4P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R4P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_cr4p.html"},{"title":"check_alloc_rank2_CR8P – Fortran Logger","text":"private subroutine check_alloc_rank2_CR8P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R8P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_cr8p.html"},{"title":"check_alloc_rank2_CR16P – Fortran Logger","text":"private subroutine check_alloc_rank2_CR16P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R16P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_cr16p.html"},{"title":"check_alloc_rank3_CR4P – Fortran Logger","text":"private subroutine check_alloc_rank3_CR4P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R4P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_cr4p.html"},{"title":"check_alloc_rank3_CR8P – Fortran Logger","text":"private subroutine check_alloc_rank3_CR8P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R8P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_cr8p.html"},{"title":"check_alloc_rank3_CR16P – Fortran Logger","text":"private subroutine check_alloc_rank3_CR16P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R16P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_cr16p.html"},{"title":"check_alloc_rank4_CR4P – Fortran Logger","text":"private subroutine check_alloc_rank4_CR4P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R4P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_cr4p.html"},{"title":"check_alloc_rank4_CR8P – Fortran Logger","text":"private subroutine check_alloc_rank4_CR8P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R8P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_cr8p.html"},{"title":"check_alloc_rank4_CR16P – Fortran Logger","text":"private subroutine check_alloc_rank4_CR16P(self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger complex ( R16P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_cr16p.html"},{"title":"check_alloc_rank1_R4P – Fortran Logger","text":"private subroutine check_alloc_rank1_R4P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R4P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_r4p.html"},{"title":"check_alloc_rank1_R8P – Fortran Logger","text":"private subroutine check_alloc_rank1_R8P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R8P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_r8p.html"},{"title":"check_alloc_rank1_R16P – Fortran Logger","text":"private subroutine check_alloc_rank1_R16P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R16P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_r16p.html"},{"title":"check_alloc_rank2_R4P – Fortran Logger","text":"private subroutine check_alloc_rank2_R4P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R4P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_r4p.html"},{"title":"check_alloc_rank2_R8P – Fortran Logger","text":"private subroutine check_alloc_rank2_R8P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R8P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_r8p.html"},{"title":"check_alloc_rank2_R16P – Fortran Logger","text":"private subroutine check_alloc_rank2_R16P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R16P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_r16p.html"},{"title":"check_alloc_rank3_R4P – Fortran Logger","text":"private subroutine check_alloc_rank3_R4P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R4P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_r4p.html"},{"title":"check_alloc_rank3_R8P – Fortran Logger","text":"private subroutine check_alloc_rank3_R8P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R8P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_r8p.html"},{"title":"check_alloc_rank3_R16P – Fortran Logger","text":"private subroutine check_alloc_rank3_R16P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R16P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_r16p.html"},{"title":"check_alloc_rank4_R4P – Fortran Logger","text":"private subroutine check_alloc_rank4_R4P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R4P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_r4p.html"},{"title":"check_alloc_rank4_R8P – Fortran Logger","text":"private subroutine check_alloc_rank4_R8P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R8P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_r8p.html"},{"title":"check_alloc_rank4_R16P – Fortran Logger","text":"private subroutine check_alloc_rank4_R16P(self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger real ( R16P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_r16p.html"},{"title":"check_alloc_rank1_I1P – Fortran Logger","text":"private subroutine check_alloc_rank1_I1P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_i1p.html"},{"title":"check_alloc_rank1_I2P – Fortran Logger","text":"private subroutine check_alloc_rank1_I2P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_i2p.html"},{"title":"check_alloc_rank1_I4P – Fortran Logger","text":"private subroutine check_alloc_rank1_I4P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_i4p.html"},{"title":"check_alloc_rank1_I8P – Fortran Logger","text":"private subroutine check_alloc_rank1_I8P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ), allocatable :: my_buffer (:) call logger % initialize () allocate ( my_buffer ( 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank1_i8p.html"},{"title":"check_alloc_rank2_I1P – Fortran Logger","text":"private subroutine check_alloc_rank2_I1P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_i1p.html"},{"title":"check_alloc_rank2_I2P – Fortran Logger","text":"private subroutine check_alloc_rank2_I2P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_i2p.html"},{"title":"check_alloc_rank2_I4P – Fortran Logger","text":"private subroutine check_alloc_rank2_I4P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_i4p.html"},{"title":"check_alloc_rank2_I8P – Fortran Logger","text":"private subroutine check_alloc_rank2_I8P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ), allocatable :: my_buffer (:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank2_i8p.html"},{"title":"check_alloc_rank3_I1P – Fortran Logger","text":"private subroutine check_alloc_rank3_I1P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_i1p.html"},{"title":"check_alloc_rank3_I2P – Fortran Logger","text":"private subroutine check_alloc_rank3_I2P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_i2p.html"},{"title":"check_alloc_rank3_I4P – Fortran Logger","text":"private subroutine check_alloc_rank3_I4P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_i4p.html"},{"title":"check_alloc_rank3_I8P – Fortran Logger","text":"private subroutine check_alloc_rank3_I8P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ), allocatable :: my_buffer (:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank3_i8p.html"},{"title":"check_alloc_rank4_I1P – Fortran Logger","text":"private subroutine check_alloc_rank4_I1P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I1P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_i1p.html"},{"title":"check_alloc_rank4_I2P – Fortran Logger","text":"private subroutine check_alloc_rank4_I2P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I2P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_i2p.html"},{"title":"check_alloc_rank4_I4P – Fortran Logger","text":"private subroutine check_alloc_rank4_I4P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I4P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_i4p.html"},{"title":"check_alloc_rank4_I8P – Fortran Logger","text":"private subroutine check_alloc_rank4_I8P(self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. use fortran_logger use penf type ( fortran_logger_t ) :: logger integer ( I8P ), allocatable :: my_buffer (:,:,:,:) call logger % initialize () allocate ( my_buffer ( 10 , 10 , 10 , 10 )) call logger % check_alloc ( my_buffer , 'my_buffer' ) Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ Contents None","tags":"","loc":"proc/check_alloc_rank4_i8p.html"},{"title":"print – Fortran Logger","text":"private subroutine print(self, level, message, routine, line, file, error_code, rank) Logger printer Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: level Level of the message character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name integer(kind=I4P), intent(in), optional :: line Source file line character(len=*), intent(in), optional :: file Source file name integer(kind=I4P), intent(in), optional :: error_code Occured error code integer(kind=I4P), intent(in), optional :: rank MPI rank Calls proc~~print~~CallsGraph proc~print print str str proc~print->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print.html"},{"title":"test_check_json – Fortran Logger","text":"public subroutine test_check_json(logger, rank) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(in) :: rank MPI processes number Called by proc~~test_check_json~~CalledByGraph proc~test_check_json test_check_json program~run_tests run_tests program~run_tests->proc~test_check_json Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_check_json.html"},{"title":"test_check_alloc – Fortran Logger","text":"public subroutine test_check_alloc(logger) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class Called by proc~~test_check_alloc~~CalledByGraph proc~test_check_alloc test_check_alloc program~run_tests run_tests program~run_tests->proc~test_check_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_check_alloc.html"},{"title":"test_ignore_error_codes – Fortran Logger","text":"public subroutine test_ignore_error_codes(logger) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class Calls proc~~test_ignore_error_codes~~CallsGraph proc~test_ignore_error_codes test_ignore_error_codes str str proc~test_ignore_error_codes->str interface~errored_subroutine errored_subroutine proc~test_ignore_error_codes->interface~errored_subroutine proc~errored_subroutine_i4p errored_subroutine_I4P interface~errored_subroutine->proc~errored_subroutine_i4p proc~errored_subroutine_i1p errored_subroutine_I1P interface~errored_subroutine->proc~errored_subroutine_i1p proc~errored_subroutine_i2p errored_subroutine_I2P interface~errored_subroutine->proc~errored_subroutine_i2p proc~errored_subroutine_logical errored_subroutine_LOGICAL interface~errored_subroutine->proc~errored_subroutine_logical proc~errored_subroutine_i8p errored_subroutine_I8P interface~errored_subroutine->proc~errored_subroutine_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_ignore_error_codes~~CalledByGraph proc~test_ignore_error_codes test_ignore_error_codes program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_ignore_error_codes.html"},{"title":"errored_subroutine_I1P – Fortran Logger","text":"private subroutine errored_subroutine_I1P(logger, error) Dummy external subroutine that returns non-zero error code, 1 byte Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I1P), intent(out) :: error Error code Called by proc~~errored_subroutine_i1p~~CalledByGraph proc~errored_subroutine_i1p errored_subroutine_I1P interface~errored_subroutine errored_subroutine interface~errored_subroutine->proc~errored_subroutine_i1p proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errored_subroutine_i1p.html"},{"title":"errored_subroutine_I2P – Fortran Logger","text":"private subroutine errored_subroutine_I2P(logger, error) Dummy external subroutine that returns non-zero error code, 2 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I2P), intent(out) :: error Error code Called by proc~~errored_subroutine_i2p~~CalledByGraph proc~errored_subroutine_i2p errored_subroutine_I2P interface~errored_subroutine errored_subroutine interface~errored_subroutine->proc~errored_subroutine_i2p proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errored_subroutine_i2p.html"},{"title":"errored_subroutine_I4P – Fortran Logger","text":"private subroutine errored_subroutine_I4P(logger, error) Dummy external subroutine that returns non-zero error code, 4 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(out) :: error Error code Called by proc~~errored_subroutine_i4p~~CalledByGraph proc~errored_subroutine_i4p errored_subroutine_I4P interface~errored_subroutine errored_subroutine interface~errored_subroutine->proc~errored_subroutine_i4p proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errored_subroutine_i4p.html"},{"title":"errored_subroutine_I8P – Fortran Logger","text":"private subroutine errored_subroutine_I8P(logger, error) Dummy external subroutine that returns non-zero error code, 8 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I8P), intent(out) :: error Error code Called by proc~~errored_subroutine_i8p~~CalledByGraph proc~errored_subroutine_i8p errored_subroutine_I8P interface~errored_subroutine errored_subroutine interface~errored_subroutine->proc~errored_subroutine_i8p proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errored_subroutine_i8p.html"},{"title":"errored_subroutine_LOGICAL – Fortran Logger","text":"private subroutine errored_subroutine_LOGICAL(logger, error) Dummy external subroutine that returns logical False status Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class logical, intent(out) :: error Error code Called by proc~~errored_subroutine_logical~~CalledByGraph proc~errored_subroutine_logical errored_subroutine_LOGICAL interface~errored_subroutine errored_subroutine interface~errored_subroutine->proc~errored_subroutine_logical proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errored_subroutine_logical.html"},{"title":"errored_subroutine – Fortran Logger","text":"private interface errored_subroutine Generic external subroutines that return non-zero error codes Calls interface~~errored_subroutine~~CallsGraph interface~errored_subroutine errored_subroutine proc~errored_subroutine_i4p errored_subroutine_I4P interface~errored_subroutine->proc~errored_subroutine_i4p proc~errored_subroutine_i1p errored_subroutine_I1P interface~errored_subroutine->proc~errored_subroutine_i1p proc~errored_subroutine_i2p errored_subroutine_I2P interface~errored_subroutine->proc~errored_subroutine_i2p proc~errored_subroutine_logical errored_subroutine_LOGICAL interface~errored_subroutine->proc~errored_subroutine_logical proc~errored_subroutine_i8p errored_subroutine_I8P interface~errored_subroutine->proc~errored_subroutine_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~errored_subroutine~~CalledByGraph interface~errored_subroutine errored_subroutine proc~test_ignore_error_codes test_ignore_error_codes proc~test_ignore_error_codes->interface~errored_subroutine program~run_tests run_tests program~run_tests->proc~test_ignore_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures errored_subroutine_I1P errored_subroutine_I2P errored_subroutine_I4P errored_subroutine_I8P errored_subroutine_LOGICAL Module Procedures private subroutine errored_subroutine_I1P (logger, error) Dummy external subroutine that returns non-zero error code, 1 byte Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I1P), intent(out) :: error Error code private subroutine errored_subroutine_I2P (logger, error) Dummy external subroutine that returns non-zero error code, 2 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I2P), intent(out) :: error Error code private subroutine errored_subroutine_I4P (logger, error) Dummy external subroutine that returns non-zero error code, 4 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(out) :: error Error code private subroutine errored_subroutine_I8P (logger, error) Dummy external subroutine that returns non-zero error code, 8 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I8P), intent(out) :: error Error code private subroutine errored_subroutine_LOGICAL (logger, error) Dummy external subroutine that returns logical False status Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class logical, intent(out) :: error Error code","tags":"","loc":"interface/errored_subroutine.html"},{"title":"test_unit_change – Fortran Logger","text":"public subroutine test_unit_change(logger, rank, np, null_unit) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(in) :: rank MPI rank integer(kind=I4P), intent(in) :: np MPI size integer(kind=I4P), intent(in) :: null_unit /dev/null unit Calls proc~~test_unit_change~~CallsGraph proc~test_unit_change test_unit_change str str proc~test_unit_change->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_unit_change~~CalledByGraph proc~test_unit_change test_unit_change program~run_tests run_tests program~run_tests->proc~test_unit_change Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_unit_change.html"},{"title":"logger_element_object – Fortran Logger","text":"Fortran-Logger project, definition of element_object class that handles different levels outputs. Uses penf face iso_fortran_env module~~logger_element_object~~UsesGraph module~logger_element_object logger_element_object penf penf module~logger_element_object->penf face face module~logger_element_object->face iso_fortran_env iso_fortran_env module~logger_element_object->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~logger_element_object~~UsedByGraph module~logger_element_object logger_element_object module~fortran_logger fortran_logger module~fortran_logger->module~logger_element_object module~test_unit_change_m test_unit_change_m module~test_unit_change_m->module~fortran_logger module~test_check_json_m test_check_json_m module~test_check_json_m->module~fortran_logger module~test_check_alloc_m test_check_alloc_m module~test_check_alloc_m->module~fortran_logger module~test_ignore_error_codes_m test_ignore_error_codes_m module~test_ignore_error_codes_m->module~fortran_logger program~run_tests run_tests program~run_tests->module~fortran_logger program~run_tests->module~test_unit_change_m program~run_tests->module~test_check_json_m program~run_tests->module~test_check_alloc_m program~run_tests->module~test_ignore_error_codes_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types element_object Functions output get_unit Subroutines finalize initialize update_unit Derived Types type, public :: element_object Definition of Object Class Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: out_unit Unit used to print output character(len=:), private, allocatable :: string Element string character(len=:), private, allocatable :: color_fg Foreground color character(len=:), private, allocatable :: color_bg Background color character(len=:), private, allocatable :: style Style character(len=:), private, allocatable :: prefix Prefix string character(len=:), private, allocatable :: suffix Suffix string Type-Bound Procedures procedure, public, pass(self) :: finalize Finalize element procedure, public, pass(self) :: initialize Initialize element procedure, public, pass(self) :: output Return formatted output of element procedure, public, pass(self) :: update_unit Replace current out_unit with new one procedure, public, pass(self) :: get_unit Return current out_unit Functions private function output (self, update_string) Generate output message Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element character(len=*), intent(in), optional :: update_string Element string Return Value character(len=:),\n  allocatable Formatted output. private pure function get_unit (self) result(unit) Returns current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self Element Return Value integer(kind=I4P) Output unit Subroutines private pure subroutine finalize (self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element private pure subroutine initialize (self, out_unit, string, color_fg, color_bg, style, prefix, suffix) Initialization class subroutine Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in), optional :: out_unit Unit used to print output character(len=*), intent(in), optional :: string Element string character(len=*), intent(in), optional :: color_fg Foreground color character(len=*), intent(in), optional :: color_bg Background color character(len=*), intent(in), optional :: style Style character(len=*), intent(in), optional :: prefix Prefix string character(len=*), intent(in), optional :: suffix Suffix string private pure subroutine update_unit (self, new_unit) Changes current output unit Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self Element integer(kind=I4P), intent(in) :: new_unit New output unit number","tags":"","loc":"module/logger_element_object.html"},{"title":"fortran_logger – Fortran Logger","text":"Fortran-Logger project, definition of fortran_logger_t class. Uses datetime_module face flap json_module penf logger_element_object mpi_f08 module~~fortran_logger~~UsesGraph module~fortran_logger fortran_logger datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face penf penf module~fortran_logger->penf mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 json_module json_module module~fortran_logger->json_module module~logger_element_object->face module~logger_element_object->penf iso_fortran_env iso_fortran_env module~logger_element_object->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fortran_logger~~UsedByGraph module~fortran_logger fortran_logger module~test_unit_change_m test_unit_change_m module~test_unit_change_m->module~fortran_logger module~test_check_json_m test_check_json_m module~test_check_json_m->module~fortran_logger module~test_check_alloc_m test_check_alloc_m module~test_check_alloc_m->module~fortran_logger module~test_ignore_error_codes_m test_ignore_error_codes_m module~test_ignore_error_codes_m->module~fortran_logger program~run_tests run_tests program~run_tests->module~fortran_logger program~run_tests->module~test_unit_change_m program~run_tests->module~test_check_json_m program~run_tests->module~test_check_alloc_m program~run_tests->module~test_ignore_error_codes_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables LOGGER_NULL_LEVEL LOGGER_ERROR_LEVEL LOGGER_WARN_LEVEL LOGGER_INFO_LEVEL LOGGER_DEBUG_LEVEL LOGGER_ERROR_ALLOCATION_FAILED LOGGER_ERROR_JSON_VALUE_NOT_FOUND LOGGER_ERROR_JSON_VALUE_TYPE_MISMATCH LOGGER_ERROR_DIRECTORY_NOT_FOUND LOGGER_ERROR_FILE_NOT_FOUND LOGGER_ERROR_CONVERTED_LOGICAL JSON_TYPES Derived Types fortran_logger_t Subroutines finalize initialize ignore_error_codes_I1P ignore_error_codes_I2P ignore_error_codes_I4P ignore_error_codes_I8P change_unit debug info warn error gather_error_codes check_json_value check_directory check_file check_error_LOGICAL check_error_I1P check_error_I2P check_error_I4P check_error_I8P check_alloc_rank1_CR4P check_alloc_rank1_CR8P check_alloc_rank1_CR16P check_alloc_rank2_CR4P check_alloc_rank2_CR8P check_alloc_rank2_CR16P check_alloc_rank3_CR4P check_alloc_rank3_CR8P check_alloc_rank3_CR16P check_alloc_rank4_CR4P check_alloc_rank4_CR8P check_alloc_rank4_CR16P check_alloc_rank1_R4P check_alloc_rank1_R8P check_alloc_rank1_R16P check_alloc_rank2_R4P check_alloc_rank2_R8P check_alloc_rank2_R16P check_alloc_rank3_R4P check_alloc_rank3_R8P check_alloc_rank3_R16P check_alloc_rank4_R4P check_alloc_rank4_R8P check_alloc_rank4_R16P check_alloc_rank1_I1P check_alloc_rank1_I2P check_alloc_rank1_I4P check_alloc_rank1_I8P check_alloc_rank2_I1P check_alloc_rank2_I2P check_alloc_rank2_I4P check_alloc_rank2_I8P check_alloc_rank3_I1P check_alloc_rank3_I2P check_alloc_rank3_I4P check_alloc_rank3_I8P check_alloc_rank4_I1P check_alloc_rank4_I2P check_alloc_rank4_I4P check_alloc_rank4_I8P print Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: LOGGER_NULL_LEVEL = 0_I4P Null Level Code Logger will not produce output integer(kind=I4P), public, parameter :: LOGGER_ERROR_LEVEL = 1_I4P Error Level Code Logger will produce output only if error occurs integer(kind=I4P), public, parameter :: LOGGER_WARN_LEVEL = 2_I4P Warning Level Code Logger will produce Error + Warning messages integer(kind=I4P), public, parameter :: LOGGER_INFO_LEVEL = 3_I4P Info Level Code Logger will produce Error + Warning + Info messages integer(kind=I4P), public, parameter :: LOGGER_DEBUG_LEVEL = 4_I4P Debug Level Code Logger will produce all messages integer(kind=I4P), public, parameter :: LOGGER_ERROR_ALLOCATION_FAILED = -999_I4P Internal error, allocation failure integer(kind=I4P), public, parameter :: LOGGER_ERROR_JSON_VALUE_NOT_FOUND = -998_I4P Internal error, requested value not found in json file integer(kind=I4P), public, parameter :: LOGGER_ERROR_JSON_VALUE_TYPE_MISMATCH = -997_I4P Internal error, requested value has a different type integer(kind=I4P), public, parameter :: LOGGER_ERROR_DIRECTORY_NOT_FOUND = -996_I4P Internal error, requested directory not found in the path integer(kind=I4P), public, parameter :: LOGGER_ERROR_FILE_NOT_FOUND = -995_I4P Internal error, requested file not found in the path integer(kind=I4P), private, parameter :: LOGGER_ERROR_CONVERTED_LOGICAL = -994_I4P Internal error, converted from logical value character(len=*), private, parameter, dimension(0:7) :: JSON_TYPES = [\"Unknown\", \"Null   \", \"Object \", \"Array  \", \"Logical\", \"Integer\", \"Real   \", \"String \"] JSON types from json fortran library Check it out on GitHub Derived Types type, public :: fortran_logger_t Definition of Logger class Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: log_level Level of logging type( element_object ), private :: logger_object (4) Objects that handle messages from all levels type( element_object ), private :: timestamp_object Timestamp handle type( element_object ), private :: routine_object Handle of optional “routine” parameter in most of methods logical, private :: print_timestamp Timestamp printer flag character(len=:), private, allocatable :: timestamp_format Timestamp format, C style integer(kind=I4P), private, allocatable :: ignored_codes (:) Buffer that keeps all ignored codes integer(kind=I4P), private, allocatable :: gather_buf (:) Buffer that aggregates all error codes type(MPI_Comm), private :: comm MPI Communicator Type-Bound Procedures procedure, public, pass(self) :: finalize Finalization class subroutine procedure, public, pass(self) :: initialize Initialization class subroutine procedure, public, pass(self) :: error Print error message procedure, public, pass(self) :: warn Print warn message procedure, public, pass(self) :: info Print info message procedure, public, pass(self) :: debug Print debug message procedure, public, pass(self) :: change_unit Runtime output unit change procedure, public, pass(self) :: check_json_value Checks presence and type of value in json file procedure, public, pass(self) :: check_directory Checks directory presence procedure, public, pass(self) :: check_file Checks file presence generic, public :: check_error => check_error_LOGICAL, check_error_I1P, check_error_I2P, check_error_I4P, check_error_I8P Checks error code returned by external subroutine. generic, public :: check_alloc => check_alloc_rank1_CR4P, check_alloc_rank1_CR8P, check_alloc_rank1_CR16P, check_alloc_rank2_CR4P, check_alloc_rank2_CR8P, check_alloc_rank2_CR16P, check_alloc_rank3_CR4P, check_alloc_rank3_CR8P, check_alloc_rank3_CR16P, check_alloc_rank4_CR4P, check_alloc_rank4_CR8P, check_alloc_rank4_CR16P, check_alloc_rank1_R4P, check_alloc_rank1_R8P, check_alloc_rank1_R16P, check_alloc_rank2_R4P, check_alloc_rank2_R8P, check_alloc_rank2_R16P, check_alloc_rank3_R4P, check_alloc_rank3_R8P, check_alloc_rank3_R16P, check_alloc_rank4_R4P, check_alloc_rank4_R8P, check_alloc_rank4_R16P, check_alloc_rank1_I1P, check_alloc_rank1_I2P, check_alloc_rank1_I4P, check_alloc_rank1_I8P, check_alloc_rank2_I1P, check_alloc_rank2_I2P, check_alloc_rank2_I4P, check_alloc_rank2_I8P, check_alloc_rank3_I1P, check_alloc_rank3_I2P, check_alloc_rank3_I4P, check_alloc_rank3_I8P, check_alloc_rank4_I1P, check_alloc_rank4_I2P, check_alloc_rank4_I4P, check_alloc_rank4_I8P Checks allocation of buffers of different types and ranks generic, public :: ignore_error_codes => ignore_error_codes_I1P, ignore_error_codes_I2P, ignore_error_codes_I4P, ignore_error_codes_I8P Ignore codes of various types except logical procedure, private, pass(self) :: check_error_LOGICAL Checks logical error_code returned by external subroutine. procedure, private, pass(self) :: check_error_I1P Checks integer I1P error_code returned by external subroutine. procedure, private, pass(self) :: check_error_I2P Checks integer I2P error_code returned by external subroutine. procedure, private, pass(self) :: check_error_I4P Checks integer I4P error_code returned by external subroutine. procedure, private, pass(self) :: check_error_I8P Checks integer I8P error_code returned by external subroutine. procedure, private, pass(self) :: check_alloc_rank1_CR4P Checks allocation of complex R4P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_CR8P Checks allocation of complex R8P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_CR16P Checks allocation of complex R16P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank2_CR4P Checks allocation of complex R4P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_CR8P Checks allocation of complex R8P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_CR16P Checks allocation of complex R16P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank3_CR4P Checks allocation of complex R4P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_CR8P Checks allocation of complex R8P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_CR16P Checks allocation of complex R16P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank4_CR4P Checks allocation of complex R4P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_CR8P Checks allocation of complex R8P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_CR16P Checks allocation of complex R16P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank1_R4P Checks allocation of real R4P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_R8P Checks allocation of real R8P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_R16P Checks allocation of real R16P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank2_R4P Checks allocation of real R4P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_R8P Checks allocation of real R8P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_R16P Checks allocation of real R16P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank3_R4P Checks allocation of real R4P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_R8P Checks allocation of real R8P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_R16P Checks allocation of real R16P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank4_R4P Checks allocation of real R4P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_R8P Checks allocation of real R8P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_R16P Checks allocation of real R16P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank1_I1P Checks allocation of integer I1P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_I2P Checks allocation of integer I2P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_I4P Checks allocation of integer I4P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank1_I8P Checks allocation of integer I8P buffer of rank = 1 procedure, private, pass(self) :: check_alloc_rank2_I1P Checks allocation of integer I1P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_I2P Checks allocation of integer I2P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_I4P Checks allocation of integer I4P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank2_I8P Checks allocation of integer I8P buffer of rank = 2 procedure, private, pass(self) :: check_alloc_rank3_I1P Checks allocation of integer I1P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_I2P Checks allocation of integer I2P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_I4P Checks allocation of integer I4P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank3_I8P Checks allocation of integer I8P buffer of rank = 3 procedure, private, pass(self) :: check_alloc_rank4_I1P Checks allocation of integer I1P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_I2P Checks allocation of integer I2P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_I4P Checks allocation of integer I4P buffer of rank = 4 procedure, private, pass(self) :: check_alloc_rank4_I8P Checks allocation of integer I8P buffer of rank = 4 procedure, private, pass(self) :: ignore_error_codes_I1P Ignore codes type I1P procedure, private, pass(self) :: ignore_error_codes_I2P Ignore codes type I2P procedure, private, pass(self) :: ignore_error_codes_I4P Ignore codes type I4P procedure, private, pass(self) :: ignore_error_codes_I8P Ignore codes type I8P procedure, private, pass(self) :: gather_error_codes Gather error codes from all processes procedure, private, pass(self) :: print Print messages to specified unit Subroutines private subroutine finalize (self) Finalization class subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger private subroutine initialize (self, comm, log_level, error_unit, error_color_fg, error_color_bg, error_style, error_prefix, error_suffix, warn_unit, warn_color_fg, warn_color_bg, warn_style, warn_prefix, warn_suffix, info_unit, info_color_fg, info_color_bg, info_style, info_prefix, info_suffix, debug_unit, debug_color_fg, debug_color_bg, debug_style, debug_prefix, debug_suffix, routine_prefix, routine_suffix, print_timestamp, timestamp_format, timestamp_color_fg, timestamp_color_bg, timestamp_style, timestamp_prefix, timestamp_suffix) Initialization class subroutine If built with MPI support then MPI_Init must be called before calling this method Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=I4P), intent(in), optional :: log_level Level of logging integer(kind=I4P), intent(in), optional :: error_unit Unit used to print ERROR messages character(len=*), intent(in), optional :: error_color_fg ERROR foreground color character(len=*), intent(in), optional :: error_color_bg ERROR background color character(len=*), intent(in), optional :: error_style ERROR style character(len=*), intent(in), optional :: error_prefix ERROR prefix character(len=*), intent(in), optional :: error_suffix ERROR suffix integer(kind=I4P), intent(in), optional :: warn_unit Unit used to print WARN messages character(len=*), intent(in), optional :: warn_color_fg WARN foreground color character(len=*), intent(in), optional :: warn_color_bg WARN background color character(len=*), intent(in), optional :: warn_style WARN style character(len=*), intent(in), optional :: warn_prefix WARN prefix character(len=*), intent(in), optional :: warn_suffix WARN suffix integer(kind=I4P), intent(in), optional :: info_unit Unit used to print INFO messages character(len=*), intent(in), optional :: info_color_fg INFO foreground color character(len=*), intent(in), optional :: info_color_bg INFO background color character(len=*), intent(in), optional :: info_style INFO style character(len=*), intent(in), optional :: info_prefix INFO prefix character(len=*), intent(in), optional :: info_suffix INFO suffix integer(kind=I4P), intent(in), optional :: debug_unit Unit used to print DEBUG messages character(len=*), intent(in), optional :: debug_color_fg DEBUG foreground color character(len=*), intent(in), optional :: debug_color_bg DEBUG background color character(len=*), intent(in), optional :: debug_style DEBUG style character(len=*), intent(in), optional :: debug_prefix DEBUG prefix character(len=*), intent(in), optional :: debug_suffix DEBUG suffix character(len=*), intent(in), optional :: routine_prefix Routine prefix. routine is optional agrument in most of logger methods character(len=*), intent(in), optional :: routine_suffix Routine suffix. routine is optional agrument in most of logger methods logical, intent(in), optional :: print_timestamp Display current timestamp with all messages. Default is .true. character(len=*), intent(in), optional :: timestamp_format Timestamp format, C style character(len=*), intent(in), optional :: timestamp_color_fg Timestamp foreground color character(len=*), intent(in), optional :: timestamp_color_bg Timestamp background color character(len=*), intent(in), optional :: timestamp_style Timestamp style character(len=*), intent(in), optional :: timestamp_prefix Timestamp prefix character(len=*), intent(in), optional :: timestamp_suffix Timestamp suffix private subroutine ignore_error_codes_I1P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I1P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I2P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I2P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I4P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I4P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine ignore_error_codes_I8P (self, error_codes) Some error codes, returned by external subroutines might be unimportant warnings. This subroutine takes array of codes integer type I8P, which will be be ignored by logger. No message will be displayed if one the codes occurs during execution, even if error is fatal Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in) :: error_codes (:) Array of error codes that will be ignored by logger private subroutine change_unit (self, log_level, new_unit) Will change output unit for the specified logging level Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: log_level Logging level integer(kind=I4P), intent(in) :: new_unit New output unit for specified log_level private subroutine debug (self, message, routine, file, line) Will print debug message if current logging level = LOGGER_DEBUG_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where debug was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where debug was called, e.g. __LINE__ private subroutine info (self, message, routine, file, line) Will print info message if current logging level >= LOGGER_INFO_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where info was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where info was called, e.g. __LINE__ private subroutine warn (self, message, routine, file, line) Will print warn message if current logging level >= LOGGER_WARN_LEVEL Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where warn was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where warn was called, e.g. __LINE__ private subroutine error (self, message, routine, file, line, error_code, errored_rank, is_fatal) Will print error message if current logging level >= LOGGER_ERROR_LEVEL . If is_fatal = .true., program will stop execution. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error was called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error was called, e.g. __LINE__ integer(kind=I4P), intent(in), optional :: error_code Internal subroutine returned error code integer(kind=I4P), intent(in), optional :: errored_rank Rank where error occured logical, intent(in), optional :: is_fatal Fatal error. Default is .false. private subroutine gather_error_codes (self, message, error_code, routine, file, line, is_fatal, gathered_code) Gather error codes from all processes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: message Message to be printed class(*), intent(in) :: error_code Internal subroutine returned error code character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where error might have occured, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where error might have occured, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: gathered_code Aggregated error code similar on all processes. private subroutine check_json_value (self, json, json_path, expected_type, routine, is_fatal, file, line, error) Checks presence and type of value in json file Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger class(json_file), intent(inout) :: json JSON handle character(len=*), intent(in) :: json_path Path to variable integer(kind=I4P), intent(in) :: expected_type Expected variable datatype character(len=*), intent(in), optional :: routine Internal subroutine name logical, intent(in), optional :: is_fatal Fatal error. Default is .false. character(len=*), intent(in), optional :: file Source file name where json is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where json is being checked, e.g. __LINE__ integer(kind=I4P), intent(out), optional :: error Error code private subroutine check_directory (self, dir_path, is_create, routine, file, line, is_fatal, error) Checks directory presence in the specified path If directory doesn’t exist, logger can create it. Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: dir_path Path to directory logical, intent(in) :: is_create Create directory if it doesn’t exist character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code private subroutine check_file (self, file_path, routine, file, line, is_fatal, error) Checks file presence in the specified path\n Attention! This subroutine is collective. All MPI Processes must call it. Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: file_path Path to directory character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where directory is being checked, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where directory is being checked, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. integer(kind=I4P), intent(out), optional :: error Error code private subroutine check_error_LOGICAL (self, check_routine, error_code, routine, file, line, is_fatal) Checks logical error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast logical, intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Fatal error. Default is .false. Default is .false. private subroutine check_error_I1P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I1P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I1P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I2P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I2P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I2P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I4P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I4P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I4P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_error_I8P (self, check_routine, error_code, routine, file, line, is_fatal) Checks integer I8P error_code returned by external subroutine. If error occurs and is_fatal = .true., program will stop execution. Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger character(len=*), intent(in) :: check_routine Name of the external subroutine, e.g. MPI_Bcast integer(kind=I8P), intent(in) :: error_code Error code returned by external subroutine character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_error is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_error is being called, e.g. __LINE__ logical, intent(in), optional :: is_fatal Flag to stop execution is error occurs Default is .false. private subroutine check_alloc_rank1_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR4P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR8P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_CR16P (self, buffer, buffer_name, routine, file, line) Checks allocation of complex R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger complex(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R4P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R8P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_R16P (self, buffer, buffer_name, routine, file, line) Checks allocation of real R16P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger real(kind=R16P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank1_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 1 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank2_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 2 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank3_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 3 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I1P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I1P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I1P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I2P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I2P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I2P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I4P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I4P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine check_alloc_rank4_I8P (self, buffer, buffer_name, routine, file, line) Checks allocation of integer I8P buffer of rank = 4 Program will stop execution if buffer was not allocated Attention! This subroutine is collective. All MPI Processes must call it. Read more… Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I8P), intent(in), allocatable :: buffer (:,:,:,:) Buffer to be checked character(len=*), intent(in) :: buffer_name Name of the Buffer character(len=*), intent(in), optional :: routine Internal subroutine name character(len=*), intent(in), optional :: file Source file name where check_alloc is being called, e.g. __FILE__ integer(kind=I4P), intent(in), optional :: line Line where check_alloc is being called, e.g. __LINE__ private subroutine print (self, level, message, routine, line, file, error_code, rank) Logger printer Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: self Logger integer(kind=I4P), intent(in) :: level Level of the message character(len=*), intent(in) :: message Message to be printed character(len=*), intent(in), optional :: routine Internal subroutine name integer(kind=I4P), intent(in), optional :: line Source file line character(len=*), intent(in), optional :: file Source file name integer(kind=I4P), intent(in), optional :: error_code Occured error code integer(kind=I4P), intent(in), optional :: rank MPI rank","tags":"","loc":"module/fortran_logger.html"},{"title":"test_check_json_m – Fortran Logger","text":"Module to test check_json_value, check_directory and check_file of Fortran Logger Uses json_module penf fortran_logger module~~test_check_json_m~~UsesGraph module~test_check_json_m test_check_json_m module~fortran_logger fortran_logger module~test_check_json_m->module~fortran_logger json_module json_module module~test_check_json_m->json_module penf penf module~test_check_json_m->penf module~fortran_logger->json_module module~fortran_logger->penf datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 module~logger_element_object->penf module~logger_element_object->face iso_fortran_env iso_fortran_env module~logger_element_object->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~test_check_json_m~~UsedByGraph module~test_check_json_m test_check_json_m program~run_tests run_tests program~run_tests->module~test_check_json_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines test_check_json Subroutines public subroutine test_check_json (logger, rank) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(in) :: rank MPI processes number","tags":"","loc":"module/test_check_json_m.html"},{"title":"test_check_alloc_m – Fortran Logger","text":"Module to test check_alloc generic method of Fortran Logger Uses fortran_logger penf module~~test_check_alloc_m~~UsesGraph module~test_check_alloc_m test_check_alloc_m module~fortran_logger fortran_logger module~test_check_alloc_m->module~fortran_logger penf penf module~test_check_alloc_m->penf module~fortran_logger->penf datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 json_module json_module module~fortran_logger->json_module module~logger_element_object->penf module~logger_element_object->face iso_fortran_env iso_fortran_env module~logger_element_object->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~test_check_alloc_m~~UsedByGraph module~test_check_alloc_m test_check_alloc_m program~run_tests run_tests program~run_tests->module~test_check_alloc_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines test_check_alloc Subroutines public subroutine test_check_alloc (logger) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class","tags":"","loc":"module/test_check_alloc_m.html"},{"title":"test_ignore_error_codes_m – Fortran Logger","text":"Module to test check_error and ignore_error_codes generic methods of Fortran Logger Uses fortran_logger penf module~~test_ignore_error_codes_m~~UsesGraph module~test_ignore_error_codes_m test_ignore_error_codes_m module~fortran_logger fortran_logger module~test_ignore_error_codes_m->module~fortran_logger penf penf module~test_ignore_error_codes_m->penf module~fortran_logger->penf datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 json_module json_module module~fortran_logger->json_module module~logger_element_object->penf module~logger_element_object->face iso_fortran_env iso_fortran_env module~logger_element_object->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~test_ignore_error_codes_m~~UsedByGraph module~test_ignore_error_codes_m test_ignore_error_codes_m program~run_tests run_tests program~run_tests->module~test_ignore_error_codes_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces errored_subroutine Subroutines test_ignore_error_codes errored_subroutine_I1P errored_subroutine_I2P errored_subroutine_I4P errored_subroutine_I8P errored_subroutine_LOGICAL Interfaces private interface errored_subroutine Generic external subroutines that return non-zero error codes private subroutine errored_subroutine_I1P (logger, error) Dummy external subroutine that returns non-zero error code, 1 byte Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I1P), intent(out) :: error Error code private subroutine errored_subroutine_I2P (logger, error) Dummy external subroutine that returns non-zero error code, 2 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I2P), intent(out) :: error Error code private subroutine errored_subroutine_I4P (logger, error) Dummy external subroutine that returns non-zero error code, 4 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(out) :: error Error code private subroutine errored_subroutine_I8P (logger, error) Dummy external subroutine that returns non-zero error code, 8 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I8P), intent(out) :: error Error code private subroutine errored_subroutine_LOGICAL (logger, error) Dummy external subroutine that returns logical False status Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class logical, intent(out) :: error Error code Subroutines public subroutine test_ignore_error_codes (logger) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class private subroutine errored_subroutine_I1P (logger, error) Dummy external subroutine that returns non-zero error code, 1 byte Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I1P), intent(out) :: error Error code private subroutine errored_subroutine_I2P (logger, error) Dummy external subroutine that returns non-zero error code, 2 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I2P), intent(out) :: error Error code private subroutine errored_subroutine_I4P (logger, error) Dummy external subroutine that returns non-zero error code, 4 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(out) :: error Error code private subroutine errored_subroutine_I8P (logger, error) Dummy external subroutine that returns non-zero error code, 8 bytes Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I8P), intent(out) :: error Error code private subroutine errored_subroutine_LOGICAL (logger, error) Dummy external subroutine that returns logical False status Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class logical, intent(out) :: error Error code","tags":"","loc":"module/test_ignore_error_codes_m.html"},{"title":"test_unit_change_m – Fortran Logger","text":"Module to test change_unit method of Fortran Logger Uses fortran_logger penf iso_fortran_env module~~test_unit_change_m~~UsesGraph module~test_unit_change_m test_unit_change_m module~fortran_logger fortran_logger module~test_unit_change_m->module~fortran_logger penf penf module~test_unit_change_m->penf iso_fortran_env iso_fortran_env module~test_unit_change_m->iso_fortran_env module~fortran_logger->penf datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 json_module json_module module~fortran_logger->json_module module~logger_element_object->penf module~logger_element_object->iso_fortran_env module~logger_element_object->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~test_unit_change_m~~UsedByGraph module~test_unit_change_m test_unit_change_m program~run_tests run_tests program~run_tests->module~test_unit_change_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines test_unit_change Subroutines public subroutine test_unit_change (logger, rank, np, null_unit) Tester subroutine Arguments Type Intent Optional Attributes Name class( fortran_logger_t ), intent(inout) :: logger Fortran logger class integer(kind=I4P), intent(in) :: rank MPI rank integer(kind=I4P), intent(in) :: np MPI size integer(kind=I4P), intent(in) :: null_unit /dev/null unit","tags":"","loc":"module/test_unit_change_m.html"},{"title":"run_tests – Fortran Logger","text":"Uses iso_fortran_env fortran_logger test_check_alloc_m test_ignore_error_codes_m test_unit_change_m test_check_json_m penf program~~run_tests~~UsesGraph program~run_tests run_tests module~fortran_logger fortran_logger program~run_tests->module~fortran_logger module~test_unit_change_m test_unit_change_m program~run_tests->module~test_unit_change_m module~test_check_json_m test_check_json_m program~run_tests->module~test_check_json_m iso_fortran_env iso_fortran_env program~run_tests->iso_fortran_env module~test_check_alloc_m test_check_alloc_m program~run_tests->module~test_check_alloc_m module~test_ignore_error_codes_m test_ignore_error_codes_m program~run_tests->module~test_ignore_error_codes_m penf penf program~run_tests->penf module~fortran_logger->penf datetime_module datetime_module module~fortran_logger->datetime_module module~logger_element_object logger_element_object module~fortran_logger->module~logger_element_object flap flap module~fortran_logger->flap face face module~fortran_logger->face mpi_f08 mpi_f08 module~fortran_logger->mpi_f08 json_module json_module module~fortran_logger->json_module module~test_unit_change_m->module~fortran_logger module~test_unit_change_m->iso_fortran_env module~test_unit_change_m->penf module~test_check_json_m->module~fortran_logger module~test_check_json_m->penf module~test_check_json_m->json_module module~test_check_alloc_m->module~fortran_logger module~test_check_alloc_m->penf module~test_ignore_error_codes_m->module~fortran_logger module~test_ignore_error_codes_m->penf module~logger_element_object->iso_fortran_env module~logger_element_object->penf module~logger_element_object->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Program designed to test Fortran Logger Calls program~~run_tests~~CallsGraph program~run_tests run_tests proc~test_ignore_error_codes test_ignore_error_codes program~run_tests->proc~test_ignore_error_codes proc~test_check_alloc test_check_alloc program~run_tests->proc~test_check_alloc proc~test_check_json test_check_json program~run_tests->proc~test_check_json proc~test_unit_change test_unit_change program~run_tests->proc~test_unit_change str str proc~test_ignore_error_codes->str interface~errored_subroutine errored_subroutine proc~test_ignore_error_codes->interface~errored_subroutine proc~test_unit_change->str proc~errored_subroutine_i4p errored_subroutine_I4P interface~errored_subroutine->proc~errored_subroutine_i4p proc~errored_subroutine_i1p errored_subroutine_I1P interface~errored_subroutine->proc~errored_subroutine_i1p proc~errored_subroutine_i2p errored_subroutine_I2P interface~errored_subroutine->proc~errored_subroutine_i2p proc~errored_subroutine_logical errored_subroutine_LOGICAL interface~errored_subroutine->proc~errored_subroutine_logical proc~errored_subroutine_i8p errored_subroutine_I8P interface~errored_subroutine->proc~errored_subroutine_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables logger rank np null_unit out_unit err_unit Variables Type Attributes Name Initial type( fortran_logger_t ) :: logger Fortran logger class integer(kind=I4P) :: rank MPI process number integer(kind=I4P) :: np MPI number of processes integer(kind=I4P) :: null_unit Unit connected to “/dev/null” integer(kind=I4P) :: out_unit Unit used to print info and debug messages: stdout on rank = 0 and null_unit otherwise integer(kind=I4P) :: err_unit Unit used to print error and warn messages: stderr on rank = 0 and null_unit otherwise","tags":"","loc":"program/run_tests.html"}]}